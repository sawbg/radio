.TH "radio::Sinusoid" 3 "Wed Apr 13 2016" "An Inexpensive, Software-Defined IF Modulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
radio::Sinusoid \- 
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <Sinusoid\&.hpp>\fP
.PP
Inherited by \fBradio::PlTone\fP\fC [private]\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBSinusoid\fP (\fBfloat32\fP \fBfrequency\fP, \fBuint32\fP \fBsamplingRate\fP=48000)"
.br
.ti -1c
.RI "\fB~Sinusoid\fP ()"
.br
.ti -1c
.RI "\fBfloat32\fP \fBnext\fP ()"
.br
.ti -1c
.RI "\fBfloat32\fP \fBnextShifted\fP ()"
.br
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "\fBfloat32\fP \fBfrequency\fP"
.br
.ti -1c
.RI "\fBuint32\fP \fBsinIndex\fP = 0"
.br
.ti -1c
.RI "\fBuint32\fP \fBsinIndexShifted\fP = 0"
.br
.ti -1c
.RI "\fBuint32\fP \fBsamplingRate\fP"
.br
.ti -1c
.RI "\fBfloat32\fP * \fBsinusoid\fP"
.br
.ti -1c
.RI "\fBfloat32\fP * \fBsinusoidShift90\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
This class creates an easy-to-call sinusoid that will preserve its phase throughout its lifespan\&. Essentially, it is a ring buffer\&. 
.PP
Definition at line 20 of file Sinusoid\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "radio::Sinusoid::Sinusoid (\fBfloat32\fPfrequency, \fBuint32\fPsamplingRate = \fC48000\fP)"
Creates a ring-buffer sinusoid\&. 
.PP
Definition at line 77 of file Sinusoid\&.hpp\&.
.PP
.nf
77                                                              {
78         this->frequency = frequency;
79         this->samplingRate = samplingRate;
80         sinusoid = (float32*)std::malloc(samplingRate * sizeof(float32));
81         sinusoidShift90 = (float32*)std::malloc(samplingRate * sizeof(float32));
82 
83         float32 arg = 2 * M_PI * frequency / samplingRate;
84 
85         for(uint32 i = 0; i < samplingRate; i++) {
86             // cosine argument evaluates as float due to M_PI and frequency
87             sinusoid[i] = cos(arg * i);
88             sinusoidShift90[i] = sin(arg * i);
89         }
90     }
.fi
.SS "radio::Sinusoid::~Sinusoid ()"
Free arrays malloc'd in the constructor\&. 
.PP
Definition at line 92 of file Sinusoid\&.hpp\&.
.PP
.nf
92                         {
93         free(sinusoid);
94         free(sinusoidShift90);
95     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBfloat32\fP radio::Sinusoid::next ()"
Provides the next value of the sinusoid in a manner consistant with a ring buffer\&. 
.PP
Definition at line 97 of file Sinusoid\&.hpp\&.
.PP
.nf
97                            {
98         if(sinIndex >= samplingRate) sinIndex = 0;
99         return sinusoid[sinIndex++];
100     }
.fi
.SS "\fBfloat32\fP radio::Sinusoid::nextShifted ()"
Provides the next value of the sinusoid shifted 90 degrees in a manner consistant with a ring buffer\&. 
.PP
Definition at line 102 of file Sinusoid\&.hpp\&.
.PP
.nf
102                                   {
103         if(sinIndexShifted >= samplingRate) sinIndexShifted = 0;
104         return sinusoidShift90[sinIndexShifted++];
105     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBfloat32\fP radio::Sinusoid::frequency\fC [protected]\fP"
The frequency of the sinusoid 
.PP
Definition at line 48 of file Sinusoid\&.hpp\&.
.SS "\fBuint32\fP radio::Sinusoid::samplingRate\fC [protected]\fP"
The sampling rate 
.PP
Definition at line 63 of file Sinusoid\&.hpp\&.
.SS "\fBuint32\fP radio::Sinusoid::sinIndex = 0\fC [protected]\fP"
The current index of the sinusoid's unshifted array 
.PP
Definition at line 53 of file Sinusoid\&.hpp\&.
.SS "\fBuint32\fP radio::Sinusoid::sinIndexShifted = 0\fC [protected]\fP"
The current index of the shifted sinusoid's array 
.PP
Definition at line 58 of file Sinusoid\&.hpp\&.
.SS "\fBfloat32\fP* radio::Sinusoid::sinusoid\fC [protected]\fP"
Initialized as an array of the sinusoid values 
.PP
Definition at line 68 of file Sinusoid\&.hpp\&.
.SS "\fBfloat32\fP* radio::Sinusoid::sinusoidShift90\fC [protected]\fP"
Initialized as an array of the sinusoid values shifted 90 degrees 
.PP
Definition at line 74 of file Sinusoid\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for An Inexpensive, Software-Defined IF Modulator from the source code\&.
