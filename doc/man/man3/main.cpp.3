.TH "src/main.cpp" 3 "Wed Apr 13 2016" "An Inexpensive, Software-Defined IF Modulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/main.cpp \- 
.PP
contains the 'brains' of the entire project  

.SH SYNOPSIS
.br
.PP
\fC#include <cstdio>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <stdexcept>\fP
.br
\fC#include <string>\fP
.br
\fC#include <unistd\&.h>\fP
.br
\fC#include 'auxiliary\&.hpp'\fP
.br
\fC#include 'Filter\&.hpp'\fP
.br
\fC#include 'Gain\&.hpp'\fP
.br
\fC#include 'Modulator\&.hpp'\fP
.br
\fC#include 'PlTone\&.hpp'\fP
.br
\fC#include 'zdomain\&.hpp'\fP
.br

.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBmain\fP (int argc, char *argv[])"
.br
.in -1c
.SH "Detailed Description"
.PP 
contains the 'brains' of the entire project 


.PP
\fBAuthor:\fP
.RS 4
Samuel Andrew Wisner, awisner94@gmail.com 
.RE
.PP

.PP
Definition in file \fBmain\&.cpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "int main (intargc, char *argv[])"
Final result of the entire project\&. Completes all goals and more! 
.PP
Definition at line 26 of file main\&.cpp\&.
.PP
.nf
26                                  {
27 
28     // Constants
29     const uint8 NUM_TYPES = 8;
30     const uint16 BUFFER_SIZE = 16384;
31     const uint32 BUFFER_BYTE_COUNT = BUFFER_SIZE * sizeof(sint32);
32     const uint32 IQ_BUFFER_SIZE = 2 * BUFFER_SIZE;
33     const uint32 IQ_BUFFER_BYTE_COUNT = BUFFER_BYTE_COUNT * 2;
34     const uint32 SAMPLING_RATE = 48000;
35 
36     // Ensure 1 or 2 arguments given
37     if(argc > 4) {
38         std::cerr << "Error: too many arguments!" << std::endl;
39         ShowHelp();
40         return ERROR;
41     } else if(argc < 2) {
42         std::cerr << "Error: too few arguments!" << std::endl;
43         ShowHelp();
44         return ERROR;
45     }
46 
47     // Declare primative Variables
48     float32 micGain = 0;
49     float32 toneFreq = 0;
50     float32 dataBuffer[BUFFER_SIZE];
51     float32 iqBuffer[IQ_BUFFER_SIZE];
52     ModulationType type;
53 
54     // validate modulation type
55     try{
56         type = to_type(string(argv[1]));
57     } catch(std::exception ex) {
58         std::cerr << "The given modulation type is invalid!" << std::endl;
59         ShowHelp();
60     }
61 
62     // process mic gain
63     if(argc >= 3) {
64         try {
65             micGain = std::stof(argv[2]);
66         } catch(std::invalid_argument ex) {
67             std::cerr << "The specified microphone gain is not a number\&."
68                 << std::endl;
69             ShowHelp();
70         }
71     }
72 
73     // validate CTCSS tone
74     if(argc == 4) {
75         try {
76             toneFreq = std::stof(argv[3]);
77 
78             if(toneFreq < 60 || toneFreq > 260) {
79                 throw std::out_of_range("");
80             }
81         } catch(std::out_of_range ex) {
82             std::cerr << "The specified CTCSS frequency is outside of the "
83                 "standard PL tone range\&." << std::endl;
84             ShowHelp();
85         } catch(std::invalid_argument ex) {
86             std::cerr << "The specified CTCSS frequency is not a number\&."
87                 << std::endl;
88             ShowHelp();
89         }
90     }
91 
92     // Declare objects
93     Filter baseFilter(dataBuffer, BUFFER_SIZE, F_BASEBAND);
94     Gain gain(dataBuffer, BUFFER_SIZE, micGain);
95     PlTone pltone(0\&.15, dataBuffer, BUFFER_SIZE, toneFreq, SAMPLING_RATE);
96     Modulator modulator(dataBuffer, BUFFER_SIZE, type, 20000);
97 
98     // SDR guts of the program
99     while(true) {
100         // get next samples
101         read(STDIN_FILENO, &dataBuffer, BUFFER_BYTE_COUNT);
102         
103         // process/modulate samples
104         baseFilter\&.Pass();
105 //      pltone\&.Add();
106         gain\&.Apply();
107         modulator\&.Mod();
108         makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);
109         to_sint32(iqBuffer, IQ_BUFFER_SIZE);
110         
111         // write samples
112         write(STDOUT_FILENO, &iqBuffer, IQ_BUFFER_BYTE_COUNT);
113     }
114 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for An Inexpensive, Software-Defined IF Modulator from the source code\&.
