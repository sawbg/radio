.TH "radio" 3 "Sun Apr 3 2016" "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
radio \- 
.PP
contains helper-functions for \fBmain()\fP  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBFilter\fP"
.br
.ti -1c
.RI "class \fBModulator\fP"
.br
.ti -1c
.RI "class \fBSinusoid\fP"
.br
.ti -1c
.RI "class \fBSubcarrier\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAge\fP { \fBOLD\fP, \fBNEW\fP }"
.br
.ti -1c
.RI "enum \fBFractional\fP { \fBNUM\fP, \fBDEN\fP }"
.br
.ti -1c
.RI "enum \fBArgument\fP { \fBFREQ\fP = 1, \fBMODE\fP, \fBPL_TONE\fP }"
.br
.ti -1c
.RI "enum \fBModulationType\fP { \fBModulationType::DSB_LC\fP, \fBModulationType::DSB_SC\fP, \fBModulationType::USB_FILTERED\fP, \fBModulationType::USB_HILBERT\fP, \fBModulationType::LSB_FILTERED\fP, \fBModulationType::LSB_HILBERT\fP, \fBModulationType::FM_NARROW\fP, \fBModulationType::FM_WIDE\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBShowHelp\fP ()"
.br
.ti -1c
.RI "\fBModulationType\fP \fBto_type\fP (std::string str)"
.br
.ti -1c
.RI "void \fBaconj\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBfft\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBhilbert\fP (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBifft\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBmakeIQ\fP (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fP size)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBfparams\fP \fBF_BASEBAND\fP"
.br
.ti -1c
.RI "\fBfparams\fP \fBF_LOWERSIDEBAND\fP"
.br
.ti -1c
.RI "\fBfparams\fP \fBF_UPPERSIDEBAND\fP"
.br
.ti -1c
.RI "const \fBuint32\fP \fBFREQ_INTERMEDIATE\fP = 20000"
.br
.ti -1c
.RI "const \fBuint32\fP \fBSAMPLING_RATE\fP = 48000"
.br
.in -1c
.SH "Detailed Description"
.PP 
contains helper-functions for \fBmain()\fP 

Contains the classes for the various types of modulation supported by the program\&.
.PP
\fBAuthor:\fP
.RS 4
Samuel Andrew Wisner, awisner94@gmail.com
.RE
.PP
This namespace contains all the classes, functions, and enumerations used in the application\&. 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBradio::Age\fP"
Describes the age of a filter (from last Pass() or in this Pass()) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOLD \fP\fP
.TP
\fB\fINEW \fP\fP
.PP
Definition at line 50 of file definitions\&.hpp\&.
.SS "enum \fBradio::Argument\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFREQ \fP\fP
.TP
\fB\fIMODE \fP\fP
.TP
\fB\fIPL_TONE \fP\fP
.PP
Definition at line 60 of file definitions\&.hpp\&.
.SS "enum \fBradio::Fractional\fP"
Describes the numerator and denominator of a z-domain transfer function 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINUM \fP\fP
.TP
\fB\fIDEN \fP\fP
.PP
Definition at line 55 of file definitions\&.hpp\&.
.SS "enum \fBradio::ModulationType\fP\fC [strong]\fP"
Describes a form of modulation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDSB_LC \fP\fP
.TP
\fB\fIDSB_SC \fP\fP
.TP
\fB\fIUSB_FILTERED \fP\fP
.TP
\fB\fIUSB_HILBERT \fP\fP
.TP
\fB\fILSB_FILTERED \fP\fP
.TP
\fB\fILSB_HILBERT \fP\fP
.TP
\fB\fIFM_NARROW \fP\fP
.TP
\fB\fIFM_WIDE \fP\fP
.PP
Definition at line 65 of file definitions\&.hpp\&.
.SH "Function Documentation"
.PP 
.SS "void radio::aconj (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values in an array of complex float32's with their respective conjugates\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with their respective conjugates
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 84 of file zdomain\&.hpp\&.
.SS "void radio::fft (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values of an array of cfloat32's with the array's DFT using a decimation-in-frequency algorithm\&.
.PP
This code is based on code from http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with its DFT
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 90 of file zdomain\&.hpp\&.
.SS "void radio::hilbert (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fPsize)"
Performs the hilbert transfor of an array of float32's\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the source array of the REAL numbers of which to take the Hilbert transform
.br
\fIdest\fP the destination array of REAL numbers for the results of the Hilbert transform
.br
\fIsize\fP the number of elements in the data and dest arrays 
.RE
.PP

.PP
Definition at line 138 of file zdomain\&.hpp\&.
.SS "void radio::ifft (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values of an array of cfloat32's with the array's inverse DFT\&.
.PP
This code is based on code from http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with its inverse DFT
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 158 of file zdomain\&.hpp\&.
.SS "void radio::makeIQ (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fPsize)"
Produces an interleaved array of first an element from an original array of data and then an element from the original data's Hilbert transform\&. This function is intended to generate a two-channel output (I/Q output) for mixing applications\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the original data (left channel)
.br
\fIdest\fP the interleaved data (left channel original data, right channel transformed data) twice the size of the original data array
.br
\fIsize\fP the number of elements in the data array (NOT in the destination array) 
.RE
.PP

.PP
Definition at line 168 of file zdomain\&.hpp\&.
.SS "void radio::ShowHelp ()"
Displays the help information\&. 
.PP
Definition at line 20 of file auxiliary\&.hpp\&.
.SS "\fBModulationType\fP radio::to_type (std::stringstr)"
Converts a string representation of the supported modulation types (see \fBShowHelp()\fP documentation) to the enum ModulationType value\&.
.PP
This function is not as elegant as it could be\&. Ideally, I would have used a std::map<string, ModulationType> rather than a long series of if-else's\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP type of modulation in typed form
.RE
.PP
\fBReturns:\fP
.RS 4
enum value of the type of modulation 
.RE
.PP

.PP
Definition at line 58 of file auxiliary\&.hpp\&.
.SH "Variable Documentation"
.PP 
.SS "\fBfparams\fP radio::F_BASEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float32> {
        0\&.0008977019461,
            -0\&.002215694636,
            0\&.001372192986,
            0\&.001372192986,
            -0\&.002215694636,
            0\&.0008977019461  
    }, std::vector<float32> {
        1,
            -4\&.678616047,
            8\&.822912216,
            -8\&.379911423,
            4\&.007629871,
            -0\&.7719064355
    } }
.fi
Baseband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 19 of file fvectors\&.hpp\&.
.SS "\fBfparams\fP radio::F_LOWERSIDEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float32> {
        0\&.2758038938,
            2\&.763578892,
            12\&.83915043,
            36\&.47584915,
            70\&.37084961,
            96\&.76893616,
            96\&.76893616,
            70\&.37084961,
            36\&.47584915,
            12\&.83915043,
            2\&.763578892,
            0\&.2758038938
    }, std::vector<float32> {
        1,
            7\&.605497837,
            27\&.34180641,
            60\&.83375549,
            92\&.60908508,
            100\&.8363876,
            79\&.74796295,
            45\&.49822617,
            18\&.1356678,
            4\&.690036297,
            0\&.6617552638,
            0\&.0281427335   
    } }
.fi
Lower-sideband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 38 of file fvectors\&.hpp\&.
.SS "\fBfparams\fP radio::F_UPPERSIDEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float32> {
        0\&.001690387726,
            0\&.01145271584,
            0\&.03591799363,
            0\&.06576926261,
            0\&.0711934343,
            0\&.03156377375,
            -0\&.03156377375,
            -0\&.0711934343,
            -0\&.06576926261,
            -0\&.03591799363,
            -0\&.01145271584,
            -0\&.001690387726
    }, std::vector<float32> {
        1,
            9\&.465174675,
            41\&.62402725,
            112\&.0970993,
            205\&.2097626,
            267\&.9378662,
            254\&.4868011,
            175\&.7772827,
            86\&.5161972,
            28\&.89988136,
            5\&.897814751,
            0\&.5572910309
    } }
.fi
Upper-sideband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 69 of file fvectors\&.hpp\&.
.SS "const \fBuint32\fP radio::FREQ_INTERMEDIATE = 20000"
The default intermediate carrier frequency 
.PP
Definition at line 26 of file Modulator\&.hpp\&.
.SS "const \fBuint32\fP radio::SAMPLING_RATE = 48000"
The default sampling rate (frequency) 
.PP
Definition at line 31 of file Modulator\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
