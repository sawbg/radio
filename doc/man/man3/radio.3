.TH "radio" 3 "Wed Apr 13 2016" "An Inexpensive, Software-Defined IF Modulator" \" -*- nroff -*-
.ad l
.nh
.SH NAME
radio \- 
.PP
Contains the classes for the various types of modulation supported by the program\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBFilter\fP"
.br
.ti -1c
.RI "class \fBGain\fP"
.br
.ti -1c
.RI "class \fBModulator\fP"
.br
.ti -1c
.RI "class \fBPlTone\fP"
.br
.ti -1c
.RI "class \fBSinusoid\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBAge\fP { \fBOLD\fP, \fBNEW\fP }"
.br
.ti -1c
.RI "enum \fBFractional\fP { \fBNUM\fP, \fBDEN\fP }"
.br
.ti -1c
.RI "enum \fBArgument\fP { \fBFREQ\fP = 1, \fBMODE\fP, \fBPL_TONE\fP }"
.br
.ti -1c
.RI "enum \fBModulationType\fP { \fBModulationType::DSB_LC\fP, \fBModulationType::DSB_SC\fP, \fBModulationType::USB_FILTERED\fP, \fBModulationType::USB_HILBERT\fP, \fBModulationType::LSB_FILTERED\fP, \fBModulationType::LSB_HILBERT\fP, \fBModulationType::FM_NARROW\fP, \fBModulationType::FM_WIDE\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "void \fBShowHelp\fP ()"
.br
.ti -1c
.RI "void \fBto_sint32\fP (\fBfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "\fBModulationType\fP \fBto_type\fP (std::string str)"
.br
.ti -1c
.RI "void \fBaconj\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBfft\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBhilbert\fP (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBifft\fP (\fBcfloat32\fP *data, \fBuint32\fP size)"
.br
.ti -1c
.RI "void \fBmakeIQ\fP (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fP size)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBfparams\fP \fBF_BASEBAND\fP"
.br
.ti -1c
.RI "\fBfparams\fP \fBF_LOWERSIDEBAND\fP"
.br
.ti -1c
.RI "\fBfparams\fP \fBF_UPPERSIDEBAND\fP"
.br
.ti -1c
.RI "const \fBuint32\fP \fBFREQ_INTERMEDIATE\fP = 20000"
.br
.ti -1c
.RI "const \fBuint32\fP \fBSAMPLING_RATE\fP = 48000"
.br
.in -1c
.SH "Detailed Description"
.PP 
Contains the classes for the various types of modulation supported by the program\&. 

This namespace contains all the classes, functions, and enumerations used in the application\&.
.PP
\fBAuthor:\fP
.RS 4
Samuel Andrew Wisner, awisner94@gmail.com 
.RE
.PP
\fBBug\fP
.RS 4
both FM modulations don't work 
.PP
clicking on the filtered SSB 
.RE
.PP

.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBradio::Age\fP"
Describes the age of a filter (from last Pass() or in this Pass()) 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIOLD \fP\fP
.TP
\fB\fINEW \fP\fP
.PP
Definition at line 52 of file definitions\&.hpp\&.
.PP
.nf
52 { OLD, NEW };
.fi
.SS "enum \fBradio::Argument\fP"
Describes the arguments in argv\&. Never actually used\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIFREQ \fP\fP
.TP
\fB\fIMODE \fP\fP
.TP
\fB\fIPL_TONE \fP\fP
.PP
Definition at line 62 of file definitions\&.hpp\&.
.PP
.nf
62 { FREQ = 1, MODE, PL_TONE };
.fi
.SS "enum \fBradio::Fractional\fP"
Describes the numerator and denominator of a z-domain transfer function 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINUM \fP\fP
.TP
\fB\fIDEN \fP\fP
.PP
Definition at line 57 of file definitions\&.hpp\&.
.PP
.nf
57 { NUM, DEN };
.fi
.SS "enum \fBradio::ModulationType\fP\fC [strong]\fP"
Describes a form of modulation\&. 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIDSB_LC \fP\fP
.TP
\fB\fIDSB_SC \fP\fP
.TP
\fB\fIUSB_FILTERED \fP\fP
.TP
\fB\fIUSB_HILBERT \fP\fP
.TP
\fB\fILSB_FILTERED \fP\fP
.TP
\fB\fILSB_HILBERT \fP\fP
.TP
\fB\fIFM_NARROW \fP\fP
.TP
\fB\fIFM_WIDE \fP\fP
.PP
Definition at line 67 of file definitions\&.hpp\&.
.PP
.nf
67                               { DSB_LC, DSB_SC, USB_FILTERED, USB_HILBERT,
68         LSB_FILTERED, LSB_HILBERT, FM_NARROW, FM_WIDE };
.fi
.SH "Function Documentation"
.PP 
.SS "void radio::aconj (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values in an array of complex float32's with their respective conjugates\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with their respective conjugates
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 84 of file zdomain\&.hpp\&.
.PP
.nf
84                                             {
85         for(int i = 0; i < size; i++) {
86             data[i] = std::conj(data[i]);
87         }
88     }
.fi
.SS "void radio::fft (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values of an array of cfloat32's with the array's DFT using a decimation-in-frequency algorithm\&.
.PP
This code is based on code from http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with its DFT
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 90 of file zdomain\&.hpp\&.
.PP
.nf
90                                           {
91         // DFT
92         uint32 k = size;
93         uint32 n;
94         float32 thetaT = M_PI / size;
95         cfloat32 phiT(cos(thetaT), sin(thetaT));
96         cfloat32 T;
97 
98         while(k > 1) {
99             n = k;
100             k >>= 1;
101             phiT = phiT * phiT;
102             T = 1\&.0L;
103 
104             for(uint32 l = 0; l < k; l++) {
105                 for(uint32 a = l; a < size; a += n) {
106                     uint32 b = a + k;
107                     cfloat32 t = data[a] -data[b];
108                     data[a] +=data[b];
109                     data[b] = t * T;
110                 }
111 
112                 T *= phiT;
113             }
114         }
115 
116         // Decimate
117         uint32 m = (uint32)log2(size);
118 
119         for(uint32 a = 0; a < size; a++) {
120             uint32 b = a;
121 
122             // Reverse bits
123             b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));
124             b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));
125             b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));
126             b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));
127             b = ((b >> 16) | (b << 16)) >> (32 - m);
128 
129             if (b > a)
130             {
131                 cfloat32 t = data[a];
132                 data[a] =data[b];
133                 data[b] = t;
134             }
135         }
136     }
.fi
.SS "void radio::hilbert (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fPsize)"
Performs the hilbert transfor of an array of float32's\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the source array of the REAL numbers of which to take the Hilbert transform
.br
\fIdest\fP the destination array of REAL numbers for the results of the Hilbert transform
.br
\fIsize\fP the number of elements in the data and dest arrays 
.RE
.PP

.PP
Definition at line 138 of file zdomain\&.hpp\&.
.PP
.nf
138                                                             {
139         cfloat32* temp = (cfloat32*)std::malloc(sizeof(cfloat32) * size);
140 
141         for(int i = 0; i < size; i++) {
142             temp[i] = data[i];
143         }
144         
145         fft(temp, size);
146 
147         for(int i = size/2; i < size; i++) {
148             temp[i] = 0;
149         }
150 
151         ifft(temp, size);
152 
153         for(int i = 0; i < size; i++) {
154             // parentheses around temp prevent free() error
155             dest[i] = -2 * (temp[i]\&.imag());
156         }
157 
158         free(temp);
159     }
.fi
.SS "void radio::ifft (\fBcfloat32\fP *data, \fBuint32\fPsize)"
Replaces the values of an array of cfloat32's with the array's inverse DFT\&.
.PP
This code is based on code from http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array whose values should be replaced with its inverse DFT
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 161 of file zdomain\&.hpp\&.
.PP
.nf
161                                            {
162         aconj(data, size);
163         fft(data, size);
164         aconj(data, size);
165 
166         for(int i = 0; i < size; i++) {
167             data[i] /= size;
168         }
169     }
.fi
.SS "void radio::makeIQ (\fBfloat32\fP *data, \fBfloat32\fP *dest, \fBuint32\fPsize)"
Produces an interleaved array of first an element from an original array of data and then an element from the original data's Hilbert transform\&. This function is intended to generate a two-channel output (I/Q output) for mixing applications\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the original data (left channel)
.br
\fIdest\fP the interleaved data (left channel original data, right channel transformed data) twice the size of the original data array
.br
\fIsize\fP the number of elements in the data array (NOT in the destination array) 
.RE
.PP

.PP
Definition at line 171 of file zdomain\&.hpp\&.
.PP
.nf
171                                                            {
172         float32 quadData[size];
173         hilbert(data, quadData, size);
174 
175         for(int i = 0; i < 2 * size; i += 2) {
176             dest[i] = quadData[i/2];
177             dest[i+1] = data[i/2];
178         }
179     }
.fi
.SS "void radio::ShowHelp ()"
Displays the help information\&. 
.PP
Definition at line 22 of file auxiliary\&.hpp\&.
.PP
.nf
22                     {
23         std::cerr << std::endl << "Usage: radio [MODE] [MIC GAIN] "
24             "[PL TONE]" << std::endl << std::endl
25             << "MODE: one of the following types "
26             "of modulation" << std::endl << std::endl;
27 
28         std::cerr << "dsblc\t\tDouble sideband, large carrier" << std::endl
29             << "am\t\tAlias for dsblc" << std::endl
30             << "dsbsc\t\tDouble sideband, suppressed carrier" << std::endl
31             << "lsbhil\t\tLower sideband created via Hilbert transform"
32             << std::endl
33             << "lsbfilt\t\tLower sideband created via digital low-pass filter"
34             << std::endl
35             << "usbhil\t\tUpper sideband created via Hilbert transform"
36             << std::endl
37             << "usbfilt\t\tUpper sideband created via digital high-pass filter"
38             << std::endl
39 //          << "nfm\t\tFrequency modulation, 2\&.5 kHz bandwidth"
40             << std::endl;
41 //          << "wfm\t\tFrequency modulation, 5 kHz bandwidth" << std::endl
42 //          << "fm\t\talias for wfm" << std::endl << std::endl;
43 
44         std::cerr << "MIC GAIN: Microphone power gain expressed in decibels"
45         << std::endl << std::endl;
46 
47         std::cerr << "PL TONE: Optional specification for CTCSS tone from "
48             "60-260 Hz" << std::endl << std::endl;
49 
50         std::exit(ERROR);
51     }
.fi
.SS "void radio::to_sint32 (\fBfloat32\fP *data, \fBuint32\fPsize)"
Converts float32 samples to sint32 samples\&. Rounds conversion to nearest integer\&.
.PP
\fBParameters:\fP
.RS 4
\fIdata\fP the array containing the float32 samples that are directly replaced by their respective sint32 representations
.br
\fIsize\fP the number of elements in the data array 
.RE
.PP

.PP
Definition at line 62 of file auxiliary\&.hpp\&.
.PP
.nf
62                                                {
63         for(uint32 i = 0; i < size; i++) {
64             ((sint32*)data)[i] = (sint32)(data[i] * INT_MAX + 0\&.5);
65         }
66     }
.fi
.SS "\fBModulationType\fP radio::to_type (std::stringstr)"
Converts a string representation of the supported modulation types (see \fBShowHelp()\fP documentation) to the enum ModulationType value\&.
.PP
This function is not as elegant as it could be\&. Ideally, I would have used a std::map<string, ModulationType> rather than a long series of if-else's\&.
.PP
\fBParameters:\fP
.RS 4
\fIstr\fP type of modulation in typed form
.RE
.PP
\fBReturns:\fP
.RS 4
enum value of the type of modulation 
.RE
.PP

.PP
Definition at line 80 of file auxiliary\&.hpp\&.
.PP
.nf
80                                           {
81         ModulationType type;
82 
83         if(str == "dsblc" || str == "am") {
84             type = ModulationType::DSB_LC;
85         } else if(str == "dsbsc") {
86             type = ModulationType::DSB_SC;
87         } else if(str == "lsbhil") {
88             type = ModulationType::LSB_HILBERT;
89         } else if(str == "lsbfilt") {
90             type = ModulationType::LSB_FILTERED;
91         } else if(str == "usbhil") {
92             type = ModulationType::USB_HILBERT;
93         } else if(str == "usbfilt") {
94             type = ModulationType::USB_FILTERED;
95         } else if(str == "wfm" || str == "fm") {
96             type = ModulationType::FM_NARROW;
97         } else if(str == "nfm") {
98             type = ModulationType::FM_WIDE;
99         } else {
100             throw std::logic_error("The given modulation type is invalid!");
101         }
102 
103         return type;
104     }
.fi
.SH "Variable Documentation"
.PP 
.SS "\fBfparams\fP radio::F_BASEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float64> {
        0\&.0008977019461,
            -0\&.002215694636,
            0\&.001372192986,
            0\&.001372192986,
            -0\&.002215694636,
            0\&.0008977019461  
    }, std::vector<float64> {
        1,
            -4\&.678616047,
            8\&.822912216,
            -8\&.379911423,
            4\&.007629871,
            -0\&.7719064355
    } }
.fi
Baseband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 19 of file fvectors\&.hpp\&.
.SS "\fBfparams\fP radio::F_LOWERSIDEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float64> {
        0\&.2758039069174,   
            2\&.763578787693,   
            12\&.83915022756,   
            36\&.47584850651,
            70\&.37084637368,   
            96\&.76893503179,   
            96\&.76893503179,   
            70\&.37084637368,
            36\&.47584850651,   
            12\&.83915022756,   
            2\&.763578787693,  
            0\&.2758039069174    
    }, std::vector<float64> {
        1,
            7\&.605497780083,   
            27\&.34180552438,   
            60\&.83375457605,
            92\&.60908886875,       
            100\&.8363857,    
            79\&.74796574736,     
            45\&.4982252145,
            18\&.13566776308,    
            4\&.690036472717,   
            0\&.6617552879305,   
            0\&.0281427334611
    } }
.fi
Lower-sideband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 38 of file fvectors\&.hpp\&.
.SS "\fBfparams\fP radio::F_UPPERSIDEBAND"
\fBInitial value:\fP
.PP
.nf
= { std::vector<float64> {
        0\&.001690387681463, 
            0\&.01145271586989, 
            0\&.03591799189724, 
            0\&.06576926098562,
            0\&.07119343282702,
            0\&.03156377419766,
            -0\&.03156377419766,
            -0\&.07119343282702,
            -0\&.06576926098562,
            -0\&.03591799189724,
            -0\&.01145271586989,
            -0\&.001690387681463
    }, std::vector<float64> {
        1,  
            9\&.465175013624,
            41\&.62402815905,
            112\&.0971027069,
            205\&.2097686473,    
            267\&.9378582311,     
            254\&.486805213,
            175\&.7772755115,
            86\&.51619894548,   
            28\&.89988093561,     
            5\&.89781461091,
            0\&.5572910543053    
    } }
.fi
Upper-sideband filter coefficients\&. Generated with MATLAB 2015A\&. 
.PP
Definition at line 69 of file fvectors\&.hpp\&.
.SS "const \fBuint32\fP radio::FREQ_INTERMEDIATE = 20000"
The default intermediate carrier frequency 
.PP
Definition at line 28 of file Modulator\&.hpp\&.
.SS "const \fBuint32\fP radio::SAMPLING_RATE = 48000"
The default sampling rate (frequency) 
.PP
Definition at line 33 of file Modulator\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for An Inexpensive, Software-Defined IF Modulator from the source code\&.
