{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment An Inexpensive, Software-Defined IF Modulator }An Inexpensive, Software-Defined IF Modulator}
{\comment Generated byDoxgyen. }
{\creatim \yr2016\mo4\dy13\hr5\min22\sec39}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Bug List{\tc \v Bug List}\par \pard\plain 
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
File {\b alsa_test.cpp}  \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Clicking noise from sinusoidal discontinuity  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
File {\b Filter.hpp}  \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid discontinuities created at the beginning of each pass  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
File {\b modulator_test.cpp}  \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid filtered SSB clicking  \par}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
Namespace {\b radio}  \par
}
{\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid both FM modulations don't work \par
clicking on the filtered SSB \par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b radio} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
radio::Filter\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
radio::Gain\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
radio::Modulator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
radio::Sinusoid\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
radio::PlTone\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b radio::Filter} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b radio::Gain} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b radio::Modulator} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b radio::PlTone} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b radio::Sinusoid} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b makefile} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains recipes to compile the main program and the tests programs as well as making documentation and counting total lines of code in src/ })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b bbftest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b lsbftest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b modtest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b msintest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b pltest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b radio} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b sintest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b bin/{\b usbftest} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b etc/{\b doxygen.config} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains doxygen configuration })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b alsa_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests sinusoidal tone generation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b auxiliary.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains helper-functions for {\b main()} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b baseband_filter_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to demonstrate the the baseband/AF filter })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b definitions.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declarations of system-independant (universal size) integers and float types, shortened type names for some commonly used types, and enumerations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b fft_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b fft_test2.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations in {\b zdomain.hpp} })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Filter.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the Filter class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b fvectors.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the transfer function coefficients used in the instances of the Filter class in this program })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Gain.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Gain class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b iq_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates test IQ signal })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b lsb_filter_test.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b main.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
"brains" of the entire project })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b mic_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests getting mic input via ALSA  May not even compile at the moment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Modulator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b modulator_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test program to test the Modulator class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b multi_sinusoid_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to demonstrate the ability of the Sinusoid class and the sound card to generate sinusoids accross the spectrum })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b piped_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Containts the original program used to test the piping-in idea })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b pl_tone_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test program to test the PlTone class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b PlTone.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
PlTone class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b Sinusoid.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sinusoid class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b sinusoid_test.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Test program to test the Sinusoid class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b usb_filter_test.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b src/{\b zdomain.hpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the functions to manipulate sequential data in the frequency (z) domain })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio Namespace Reference\par \pard\plain 
{\tc\tcl2 \v radio}
{\xe \v radio}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Filter}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Gain}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Modulator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PlTone}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Sinusoid}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Age} \{ {\b OLD}, 
{\b NEW}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Fractional} \{ {\b NUM}, 
{\b DEN}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Argument} \{ {\b FREQ} = 1, 
{\b MODE}, 
{\b PL_TONE}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ModulationType} \{ {\b ModulationType::DSB_LC}, 
{\b ModulationType::DSB_SC}, 
{\b ModulationType::USB_FILTERED}, 
{\b ModulationType::USB_HILBERT}, 
{\b ModulationType::LSB_FILTERED}, 
{\b ModulationType::LSB_HILBERT}, 
{\b ModulationType::FM_NARROW}, 
{\b ModulationType::FM_WIDE}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShowHelp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b to_sint32} ({\b float32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ModulationType} {\b to_type} (std::string str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b aconj} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fft} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hilbert} ({\b float32} *data, {\b float32} *dest, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ifft} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b makeIQ} ({\b float32} *data, {\b float32} *dest, {\b uint32} size)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b F_BASEBAND}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b F_LOWERSIDEBAND}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b F_UPPERSIDEBAND}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b uint32} {\b FREQ_INTERMEDIATE} = 20000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b uint32} {\b SAMPLING_RATE} = 48000\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This namespace contains all the classes, functions, and enumerations used in the application.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid both FM modulations don't work \par
clicking on the filtered SSB \par
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v Age\:radio}
{\xe \v radio\:Age}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b radio::Age}}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes the age of a filter (from last Pass() or in this Pass()) \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v OLD\:radio}
{\xe \v radio\:OLD}
{\b {\i OLD{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
}}  \par
{\xe \v NEW\:radio}
{\xe \v radio\:NEW}
{\b {\i NEW{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
}}  \par
}{
Definition at line 52 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 52 \{ OLD, NEW \};\par
}
}
{\xe \v Argument\:radio}
{\xe \v radio\:Argument}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b radio::Argument}}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes the arguments in argv. Never actually used. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v FREQ\:radio}
{\xe \v radio\:FREQ}
{\b {\i FREQ{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
}}  \par
{\xe \v MODE\:radio}
{\xe \v radio\:MODE}
{\b {\i MODE{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
}}  \par
{\xe \v PL_TONE\:radio}
{\xe \v radio\:PL_TONE}
{\b {\i PL_TONE{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
}}  \par
}{
Definition at line 62 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62 \{ FREQ = 1, MODE, PL_TONE \};\par
}
}
{\xe \v Fractional\:radio}
{\xe \v radio\:Fractional}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b radio::Fractional}}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes the numerator and denominator of a z-domain transfer function \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v NUM\:radio}
{\xe \v radio\:NUM}
{\b {\i NUM{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
}}  \par
{\xe \v DEN\:radio}
{\xe \v radio\:DEN}
{\b {\i DEN{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
}}  \par
}{
Definition at line 57 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 57 \{ NUM, DEN \};\par
}
}
{\xe \v ModulationType\:radio}
{\xe \v radio\:ModulationType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b radio::ModulationType}{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Describes a form of modulation. \par
}{{{\b Enumerator}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v DSB_LC\:radio}
{\xe \v radio\:DSB_LC}
{\b {\i DSB_LC{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
}}  \par
{\xe \v DSB_SC\:radio}
{\xe \v radio\:DSB_SC}
{\b {\i DSB_SC{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
}}  \par
{\xe \v USB_FILTERED\:radio}
{\xe \v radio\:USB_FILTERED}
{\b {\i USB_FILTERED{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
}}  \par
{\xe \v USB_HILBERT\:radio}
{\xe \v radio\:USB_HILBERT}
{\b {\i USB_HILBERT{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
}}  \par
{\xe \v LSB_FILTERED\:radio}
{\xe \v radio\:LSB_FILTERED}
{\b {\i LSB_FILTERED{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
}}  \par
{\xe \v LSB_HILBERT\:radio}
{\xe \v radio\:LSB_HILBERT}
{\b {\i LSB_HILBERT{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
}}  \par
{\xe \v FM_NARROW\:radio}
{\xe \v radio\:FM_NARROW}
{\b {\i FM_NARROW{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
}}  \par
{\xe \v FM_WIDE\:radio}
{\xe \v radio\:FM_WIDE}
{\b {\i FM_WIDE{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
}}  \par
}{
Definition at line 67 of file definitions.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                               \{ DSB_LC, DSB_SC, USB_FILTERED, USB_HILBERT,\par
68         LSB_FILTERED, LSB_HILBERT, FM_NARROW, FM_WIDE \};\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v aconj\:radio}
{\xe \v radio\:aconj}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::aconj ({\b cfloat32} * {\i data}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the values in an array of complex float32's with their respective conjugates.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the array whose values should be replaced with their respective conjugates\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array \cell }
{\row }
}
}{
Definition at line 84 of file zdomain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 84                                             \{\par
85         for(int i = 0; i < size; i++) \{\par
86             data[i] = std::conj(data[i]);\par
87         \}\par
88     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_aa04bb922c40cafb00a5603f1fc6d9c26_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v fft\:radio}
{\xe \v radio\:fft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::fft ({\b cfloat32} * {\i data}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the values of an array of cfloat32's with the array's DFT using a decimation-in-frequency algorithm.\par
This code is based on code from {\f2 http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the array whose values should be replaced with its DFT\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array \cell }
{\row }
}
}{
Definition at line 90 of file zdomain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 90                                           \{\par
91         // DFT\par
92         uint32 k = size;\par
93         uint32 n;\par
94         float32 thetaT = M_PI / size;\par
95         cfloat32 phiT(cos(thetaT), sin(thetaT));\par
96         cfloat32 T;\par
97 \par
98         while(k > 1) \{\par
99             n = k;\par
100             k >>= 1;\par
101             phiT = phiT * phiT;\par
102             T = 1.0L;\par
103 \par
104             for(uint32 l = 0; l < k; l++) \{\par
105                 for(uint32 a = l; a < size; a += n) \{\par
106                     uint32 b = a + k;\par
107                     cfloat32 t = data[a] -data[b];\par
108                     data[a] +=data[b];\par
109                     data[b] = t * T;\par
110                 \}\par
111 \par
112                 T *= phiT;\par
113             \}\par
114         \}\par
115 \par
116         // Decimate\par
117         uint32 m = (uint32)log2(size);\par
118 \par
119         for(uint32 a = 0; a < size; a++) \{\par
120             uint32 b = a;\par
121 \par
122             // Reverse bits\par
123             b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\par
124             b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\par
125             b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\par
126             b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\par
127             b = ((b >> 16) | (b << 16)) >> (32 - m);\par
128 \par
129             if (b > a)\par
130             \{\par
131                 cfloat32 t = data[a];\par
132                 data[a] =data[b];\par
133                 data[b] = t;\par
134             \}\par
135         \}\par
136     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_ab146b5bf7f1c005939b024c9c4910a77_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v hilbert\:radio}
{\xe \v radio\:hilbert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::hilbert ({\b float32} * {\i data}, {\b float32} * {\i dest}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs the hilbert transfor of an array of float32's.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the source array of the REAL numbers of which to take the Hilbert transform\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{the destination array of REAL numbers for the results of the Hilbert transform\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data and dest arrays \cell }
{\row }
}
}{
Definition at line 138 of file zdomain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 138                                                             \{\par
139         cfloat32* temp = (cfloat32*)std::malloc(sizeof(cfloat32) * size);\par
140 \par
141         for(int i = 0; i < size; i++) \{\par
142             temp[i] = data[i];\par
143         \}\par
144         \par
145         fft(temp, size);\par
146 \par
147         for(int i = size/2; i < size; i++) \{\par
148             temp[i] = 0;\par
149         \}\par
150 \par
151         ifft(temp, size);\par
152 \par
153         for(int i = 0; i < size; i++) \{\par
154             // parentheses around temp prevent free() error\par
155             dest[i] = -2 * (temp[i].imag());\par
156         \}\par
157 \par
158         free(temp);\par
159     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a285a47b4ed81e5662d2b6b4bae0188d0_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a285a47b4ed81e5662d2b6b4bae0188d0_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ifft\:radio}
{\xe \v radio\:ifft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::ifft ({\b cfloat32} * {\i data}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Replaces the values of an array of cfloat32's with the array's inverse DFT.\par
This code is based on code from {\f2 http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the array whose values should be replaced with its inverse DFT\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array \cell }
{\row }
}
}{
Definition at line 161 of file zdomain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 161                                            \{\par
162         aconj(data, size);\par
163         fft(data, size);\par
164         aconj(data, size);\par
165 \par
166         for(int i = 0; i < size; i++) \{\par
167             data[i] /= size;\par
168         \}\par
169     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a51add4e2faf6d58cabc3b4a3892420eb_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a51add4e2faf6d58cabc3b4a3892420eb_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v makeIQ\:radio}
{\xe \v radio\:makeIQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::makeIQ ({\b float32} * {\i data}, {\b float32} * {\i dest}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Produces an interleaved array of first an element from an original array of data and then an element from the original data's Hilbert transform. This function is intended to generate a two-channel output (I/Q output) for mixing applications.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the original data (left channel)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i dest} \cell }{the interleaved data (left channel original data, right channel transformed data) twice the size of the original data array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array (NOT in the destination array) \cell }
{\row }
}
}{
Definition at line 171 of file zdomain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 171                                                            \{\par
172         float32 quadData[size];\par
173         hilbert(data, quadData, size);\par
174 \par
175         for(int i = 0; i < 2 * size; i += 2) \{\par
176             dest[i] = quadData[i/2];\par
177             dest[i+1] = data[i/2];\par
178         \}\par
179     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a7166522e76ff88e8d482491b1b6e2275_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a7166522e76ff88e8d482491b1b6e2275_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ShowHelp\:radio}
{\xe \v radio\:ShowHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::ShowHelp ()}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Displays the help information. \par
}{
Definition at line 22 of file auxiliary.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22                     \{\par
23         std::cerr << std::endl << "Usage: radio [MODE] [MIC GAIN] "\par
24             "[PL TONE]" << std::endl << std::endl\par
25             << "MODE: one of the following types "\par
26             "of modulation" << std::endl << std::endl;\par
27 \par
28         std::cerr << "dsblc\\t\\tDouble sideband, large carrier" << std::endl\par
29             << "am\\t\\tAlias for dsblc" << std::endl\par
30             << "dsbsc\\t\\tDouble sideband, suppressed carrier" << std::endl\par
31             << "lsbhil\\t\\tLower sideband created via Hilbert transform"\par
32             << std::endl\par
33             << "lsbfilt\\t\\tLower sideband created via digital low-pass filter"\par
34             << std::endl\par
35             << "usbhil\\t\\tUpper sideband created via Hilbert transform"\par
36             << std::endl\par
37             << "usbfilt\\t\\tUpper sideband created via digital high-pass filter"\par
38             << std::endl\par
39 //          << "nfm\\t\\tFrequency modulation, 2.5 kHz bandwidth"\par
40             << std::endl;\par
41 //          << "wfm\\t\\tFrequency modulation, 5 kHz bandwidth" << std::endl\par
42 //          << "fm\\t\\talias for wfm" << std::endl << std::endl;\par
43 \par
44         std::cerr << "MIC GAIN: Microphone power gain expressed in decibels"\par
45         << std::endl << std::endl;\par
46 \par
47         std::cerr << "PL TONE: Optional specification for CTCSS tone from "\par
48             "60-260 Hz" << std::endl << std::endl;\par
49 \par
50         std::exit(ERROR);\par
51     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a6db7c682d0f9aeac8cb5042717b8ae7f_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v to_sint32\:radio}
{\xe \v radio\:to_sint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::to_sint32 ({\b float32} * {\i data}, {\b uint32} {\i size})}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts float32 samples to sint32 samples. Rounds conversion to nearest integer.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the array containing the float32 samples that are directly replaced by their respective sint32 representations\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array \cell }
{\row }
}
}{
Definition at line 62 of file auxiliary.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 62                                                \{\par
63         for(uint32 i = 0; i < size; i++) \{\par
64             ((sint32*)data)[i] = (sint32)(data[i] * INT_MAX + 0.5);\par
65         \}\par
66     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_ae4b2334c4366dcdf0311ad79d2067945_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v to_type\:radio}
{\xe \v radio\:to_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ModulationType} radio::to_type (std::string {\i str})}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Converts a string representation of the supported modulation types (see {\b ShowHelp()} documentation) to the enum ModulationType value.\par
This function is not as elegant as it could be. Ideally, I would have used a std::map<string, ModulationType> rather than a long series of if-else's.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i str} \cell }{type of modulation in typed form\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns:\par}\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid enum value of the type of modulation \par
}}{
Definition at line 80 of file auxiliary.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 80                                           \{\par
81         ModulationType type;\par
82 \par
83         if(str == "dsblc" || str == "am") \{\par
84             type = ModulationType::DSB_LC;\par
85         \} else if(str == "dsbsc") \{\par
86             type = ModulationType::DSB_SC;\par
87         \} else if(str == "lsbhil") \{\par
88             type = ModulationType::LSB_HILBERT;\par
89         \} else if(str == "lsbfilt") \{\par
90             type = ModulationType::LSB_FILTERED;\par
91         \} else if(str == "usbhil") \{\par
92             type = ModulationType::USB_HILBERT;\par
93         \} else if(str == "usbfilt") \{\par
94             type = ModulationType::USB_FILTERED;\par
95         \} else if(str == "wfm" || str == "fm") \{\par
96             type = ModulationType::FM_NARROW;\par
97         \} else if(str == "nfm") \{\par
98             type = ModulationType::FM_WIDE;\par
99         \} else \{\par
100             throw std::logic_error("The given modulation type is invalid!");\par
101         \}\par
102 \par
103         return type;\par
104     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "namespaceradio_a402fe28e2e2bb2be7a0d2d9f74cc640d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v F_BASEBAND\:radio}
{\xe \v radio\:F_BASEBAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fparams} radio::F_BASEBAND}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{ std::vector<float64> \{\par
        0.0008977019461,\par
            -0.002215694636,\par
            0.001372192986,\par
            0.001372192986,\par
            -0.002215694636,\par
            0.0008977019461 \par
    \}, std::vector<float64> \{\par
        1,\par
            -4.678616047,\par
            8.822912216,\par
            -8.379911423,\par
            4.007629871,\par
            -0.7719064355\par
    \} \}\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Baseband filter coefficients. Generated with MATLAB 2015A. \par
}{
Definition at line 19 of file fvectors.hpp.}\par
}
{\xe \v F_LOWERSIDEBAND\:radio}
{\xe \v radio\:F_LOWERSIDEBAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fparams} radio::F_LOWERSIDEBAND}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{ std::vector<float64> \{\par
        0.2758039069174,   \par
            2.763578787693,   \par
            12.83915022756,   \par
            36.47584850651,\par
            70.37084637368,   \par
            96.76893503179,   \par
            96.76893503179,   \par
            70.37084637368,\par
            36.47584850651,   \par
            12.83915022756,   \par
            2.763578787693,  \par
            0.2758039069174   \par
    \}, std::vector<float64> \{\par
        1,\par
            7.605497780083,   \par
            27.34180552438,   \par
            60.83375457605,\par
            92.60908886875,       \par
            100.8363857,    \par
            79.74796574736,     \par
            45.4982252145,\par
            18.13566776308,    \par
            4.690036472717,   \par
            0.6617552879305,   \par
            0.0281427334611\par
    \} \}\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Lower-sideband filter coefficients. Generated with MATLAB 2015A. \par
}{
Definition at line 38 of file fvectors.hpp.}\par
}
{\xe \v F_UPPERSIDEBAND\:radio}
{\xe \v radio\:F_UPPERSIDEBAND}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fparams} radio::F_UPPERSIDEBAND}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid = \{ std::vector<float64> \{\par
        0.001690387681463, \par
            0.01145271586989, \par
            0.03591799189724, \par
            0.06576926098562,\par
            0.07119343282702,\par
            0.03156377419766,\par
            -0.03156377419766,\par
            -0.07119343282702,\par
            -0.06576926098562,\par
            -0.03591799189724,\par
            -0.01145271586989,\par
            -0.001690387681463\par
    \}, std::vector<float64> \{\par
        1,  \par
            9.465175013624,\par
            41.62402815905,\par
            112.0971027069,\par
            205.2097686473,    \par
            267.9378582311,     \par
            254.486805213,\par
            175.7772755115,\par
            86.51619894548,   \par
            28.89988093561,     \par
            5.89781461091,\par
            0.5572910543053   \par
    \} \}\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Upper-sideband filter coefficients. Generated with MATLAB 2015A. \par
}{
Definition at line 69 of file fvectors.hpp.}\par
}
{\xe \v FREQ_INTERMEDIATE\:radio}
{\xe \v radio\:FREQ_INTERMEDIATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b uint32} radio::FREQ_INTERMEDIATE = 20000}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default intermediate carrier frequency \par
}{
Definition at line 28 of file Modulator.hpp.}\par
}
{\xe \v SAMPLING_RATE\:radio}
{\xe \v radio\:SAMPLING_RATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b uint32} radio::SAMPLING_RATE = 48000}}
\par
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default sampling rate (frequency) \par
}{
Definition at line 33 of file Modulator.hpp.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio::Filter Class Reference\par \pard\plain 
{\tc\tcl2 \v radio::Filter}
{\xe \v radio::Filter}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
\par
{
{\f2 #include <Filter.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Filter} ({\b float32} *{\b data}, {\b uint32} {\b size}, {\b fparams} &{\b diffEq})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Pass} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint8} {\b eqLength}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32} {\b size}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} * {\b data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b diffEq}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class implements a z-domain filter on a specified array of float32'''s (a.k.a. singles, floats). It requires the transfer function coefficients already be calculated (i.e., it does not generate the coefficients based on desired filter characteristics). MATLAB and its Signal Processing Toolbox can be used to generate the coefficients.\par
While this class is designed to implement a single-section filter, several instances of the class can be created and run over the data array sequentially to effectively implement a multi-section filter. \par
}{
Definition at line 28 of file Filter.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Filter\:radio::Filter}
{\xe \v radio::Filter\:Filter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Filter::Filter ({\b float32} * {\i data}, {\b uint32} {\i size}, {\b fparams} & {\i diffEq})}}
\par
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes {\b Filter} based on a difference equation.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{array to be filtered. The filtered data will be placed here.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{number of elements in the data array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i diffEq} \cell }{a vector containing two vectors of float32'''s (a.k.a. singles, floats), containing the numerator and denominator coefficients, respectively, of the z-domain tranfer function of the filter in decending order (z^0, z^-1, z^-2, etc.). \cell }
{\row }
}
}{
Definition at line 80 of file Filter.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 80                                                               \{\par
81         this->data = data;\par
82         this->size = size;\par
83         this->diffEq = diffEq;\par
84         eqLength = this->diffEq[DEN].size();\par
85     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Pass\:radio::Filter}
{\xe \v radio::Filter\:Pass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::Filter::Pass ()}}
\par
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Passes the data array through the digital filter but does not account for previous x[n] and y[n] values from the previous call to {\b Pass()}. \par
}{
Definition at line 87 of file Filter.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 87                       \{\par
88         float64 temp[size];\par
89 \par
90         // create first values in filtered data\par
91         for(int i = 0; i< eqLength; i++) \{\par
92             temp[i] = 0;\par
93 \par
94             for(int j = 0; j < eqLength; j++) \{\par
95                 temp[i] += diffEq[NUM][j] * (j > i ? 0 : data[i - j]);\par
96             \}\par
97 \par
98             for(int j = 1; j < eqLength; j++) \{\par
99                 temp[i] -= diffEq[DEN][j] * (j > i ? 0 : temp[i - j]);\par
100             \}\par
101         \}\par
102 \par
103         // create the REST of the values in filtered data\par
104         for(int i = eqLength; i < size; i++) \{\par
105             temp[i] = 0;\par
106 \par
107             for(int j = 0; j < eqLength; j++) \{\par
108                 temp[i] += diffEq[NUM][j] * data[i - j];\par
109             \}\par
110 \par
111             for(int j = 1; j < eqLength; j++) \{\par
112                 temp[i] -= diffEq[DEN][j] * temp[i - j];\par
113             \}\par
114         \}\par
115 \par
116         // save final values of data and filtered data\par
117     for(int i = 0; i < size; i++) \{\par
118             data[i] = temp[i];\par
119         \}\par
120     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Filter_ad2793821801780809af385463bf8f197_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v data\:radio::Filter}
{\xe \v radio::Filter\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32}* radio::Filter::data{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A pointer to the data array that should be filtered when {\b Pass()} is called. \par
}{
Definition at line 69 of file Filter.hpp.}\par
}
{\xe \v diffEq\:radio::Filter}
{\xe \v radio::Filter\:diffEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b fparams} radio::Filter::diffEq{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A vector containing two vectors of float32'''s (a.k.a. singles, floats), containing the numerator and denominator coefficients, respectively, of the z-domain tranfer function of the filter in decending order (z^0, z^-1, z^-2, etc.). \par
}{
Definition at line 77 of file Filter.hpp.}\par
}
{\xe \v eqLength\:radio::Filter}
{\xe \v radio::Filter\:eqLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint8} radio::Filter::eqLength{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of terms in the numerator (or denomenator) of the transfer function. \par
}{
Definition at line 58 of file Filter.hpp.}\par
}
{\xe \v size\:radio::Filter}
{\xe \v radio::Filter\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32} radio::Filter::size{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The number of elements in the data array. \par
}{
Definition at line 63 of file Filter.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Filter.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio::Gain Class Reference\par \pard\plain 
{\tc\tcl2 \v radio::Gain}
{\xe \v radio::Gain}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
\par
{
{\f2 #include <Gain.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Gain} ({\b float32} *data, {\b uint32} size, {\b float32} gaindB)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Apply} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies a gain to a (baseband) signal. \par
}{
Definition at line 18 of file Gain.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Gain\:radio::Gain}
{\xe \v radio::Gain\:Gain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Gain::Gain ({\b float32} * {\i data}, {\b uint32} {\i size}, {\b float32} {\i gaindB})}}
\par
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a {\b Gain} object and converts gain from decibels to a standard value.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the signal to which the gain is applied\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in the data array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i gaindB} \cell }{the desired gain in decibels (of power) \cell }
{\row }
}
}{
Definition at line 61 of file Gain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 61                                                          \{\par
62         this->data = data;\par
63         this->size = size;\par
64         gainCoeff = pow(10, gaindB / 20);\par
65     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Apply\:radio::Gain}
{\xe \v radio::Gain\:Apply}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::Gain::Apply ()}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Applies the gain to the signal contained in the data array \par
}{
Definition at line 67 of file Gain.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                      \{\par
68         for(uint32 i = 0; i < size; i++) \{\par
69             data[i] *= gainCoeff;\par
70 \par
71             if((data[i] > 1 || data[i] < -1) && !hasClipped) \{\par
72                 hasClipped = true;\par
73                 std::cerr << "Baseband clipping has occurred!"\par
74                     << std::endl;\par
75             \}\par
76         \}\par
77     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Gain_a8c6df2c5989da0e560c8f276e6138a2d_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Gain.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio::Modulator Class Reference\par \pard\plain 
{\tc\tcl2 \v radio::Modulator}
{\xe \v radio::Modulator}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
\par
{
{\f2 #include <Modulator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Modulator} ({\b float32} data[], {\b uint32} size, {\b ModulationType} type, {\b float32} freqInter={\b FREQ_INTERMEDIATE}, {\b uint32} rate={\b SAMPLING_RATE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Modulator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Mod} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class, while not intended to be called directly, is a superclass for the classes of the modulation forms used in this project. \par
}{
Definition at line 39 of file Modulator.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Modulator\:radio::Modulator}
{\xe \v radio::Modulator\:Modulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Modulator::Modulator ({\b float32} {\i data}[], {\b uint32} {\i size}, {\b ModulationType} {\i type}, {\b float32} {\i freqInter} = {\f2 {\b FREQ_INTERMEDIATE}}, {\b uint32} {\i rate} = {\f2 {\b SAMPLING_RATE}})}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b Modulator} with the specified parameters. Intended to be called only by subclasses.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i freqInter} \cell }{the frequency of the IF carrier sinusoid\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i rate} \cell }{the sampling rate of the baseband and IF signals\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{the array holding initially the baseband signal\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elements in data\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i type} \cell }{form of modulation to use \cell }
{\row }
}
}{
Definition at line 103 of file Modulator.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 104                                             \{\par
105         freqCarrier = freqInter;\par
106         this->rate = rate;\par
107         this->data = data;\par
108         this->size = size;\par
109         this->type = type;\par
110 \par
111         if(type == ModulationType::USB_HILBERT\par
112                 || type == ModulationType::LSB_HILBERT) \{\par
113             hilData = (float32*)malloc(size*sizeof(float32));\par
114         \}\par
115     \}\par
}
}
{\xe \v ~Modulator\:radio::Modulator}
{\xe \v radio::Modulator\:~Modulator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Modulator::~Modulator ()}}
\par
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 117 of file Modulator.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 117                           \{\par
118         if(hilData != nullptr) free(hilData);\par
119     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Mod\:radio::Modulator}
{\xe \v radio::Modulator\:Mod}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::Modulator::Mod ()}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Modulates the audio currently in the data array. \par
}{
Definition at line 121 of file Modulator.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 121                         \{\par
122         // these variables should only ever be created once\par
123         static float32 fmArg = 2 * M_PI * freqCarrier / (float32)rate;\par
124         static float32 fmK = 2 * M_PI / rate;\par
125         static float32 fmSum = 0;  // cummulative sum used in FM modulation\par
126         static Filter lsbFilter(data, size, F_LOWERSIDEBAND);\par
127         static Sinusoid sinusoid(freqCarrier, rate);  // IF carrier sinusoid\par
128         static Filter usbFilter(data, size, F_UPPERSIDEBAND);\par
129 \par
130         // take hilbert transform if necessary\par
131         if(type == ModulationType::USB_HILBERT\par
132                 || type == ModulationType::LSB_HILBERT) \{\par
133             hilbert(data, hilData, size);\par
134         \} else if(type == ModulationType::FM_NARROW) \{\par
135             fmK *= 2.5;\par
136         \} else if(type == ModulationType::FM_WIDE) \{\par
137             fmK *= 5;\par
138         \}\par
139 \par
140         // perform main modulation\par
141         for(uint32 i = 0; i < size; i++) \{\par
142             switch(type) \{\par
143                 case ModulationType::DSB_LC:\par
144                     data[i] = ((data[i] + 1) * sinusoid.next()) / 2;\par
145                     break;\par
146 \par
147                 case ModulationType::DSB_SC:\par
148                 case ModulationType::USB_FILTERED:\par
149                 case ModulationType::LSB_FILTERED:\par
150                     data[i] = data[i] * sinusoid.next();\par
151                     break;\par
152 \par
153                 case ModulationType::USB_HILBERT:\par
154                     data[i] = data[i] * sinusoid.next()\par
155                         - hilData[i] * sinusoid.nextShifted();\par
156                     break;\par
157 \par
158                 case ModulationType::LSB_HILBERT:\par
159                     data[i] = data[i] * sinusoid.next()\par
160                         + hilData[i] * sinusoid.nextShifted();\par
161                     break;\par
162 \par
163                 case ModulationType::FM_NARROW:\par
164                 case ModulationType::FM_WIDE:\par
165                     fmSum += fmK * data[i];\par
166                     data[i] = cos(fmArg * i + fmSum);\par
167                     break;\par
168             \}\par
169         \}\par
170 \par
171         // filter out a sideband if using filtered SSB modulation\par
172         if(type == ModulationType::LSB_FILTERED) \{\par
173             lsbFilter.Pass();\par
174         \} else if(type == ModulationType::USB_FILTERED) \{\par
175             usbFilter.Pass();\par
176         \}\par
177     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Modulator_ab5eac6e4900579486b5871b48e64cdab_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Modulator_ab5eac6e4900579486b5871b48e64cdab_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Modulator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio::PlTone Class Reference\par \pard\plain 
{\tc\tcl2 \v radio::PlTone}
{\xe \v radio::PlTone}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
\par
{
{\f2 #include <PlTone.hpp>}}\par
Inheritance diagram for radio::PlTone:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1PlTone__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
Collaboration diagram for radio::PlTone:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1PlTone__coll__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlTone} ({\b float32} amplitude, {\b float32} *data, {\b uint32} size, {\b float32} {\b frequency}, {\b uint32} {\b samplingRate})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Add} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class creates a CTCSS subcarrier (PL tone) at a specified frequency in a baseband signal. \par
}{
Definition at line 18 of file PlTone.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PlTone\:radio::PlTone}
{\xe \v radio::PlTone\:PlTone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::PlTone::PlTone ({\b float32} {\i amplitude}, {\b float32} * {\i data}, {\b uint32} {\i size}, {\b float32} {\i frequency}, {\b uint32} {\i samplingRate})}}
\par
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a {\b PlTone} object.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters:\par}
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i amplitude} \cell }{the amplitude (0-1) of the subcarrier. Assumes baseband signal has a peak-to-peak range of -1 to 1.\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i data} \cell }{an array containing a portion of the discrete baseband signal\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i size} \cell }{the number of elemeents in the data array\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i frequency} \cell }{the frequency of the CTCSS tone in the baseband (not in the IF or RF signals)\cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i samplingRate} \cell }{the sampling frequency of the baseband signal \cell }
{\row }
}
}{
Definition at line 63 of file PlTone.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 65         : Sinusoid(frequency, samplingRate) \{\par
66         this->data = data;\par
67         this->amplitude = amplitude;\par
68         this->size = size;\par
69 \par
70         for(uint32 i = 0; i < samplingRate; i++) \{\par
71             sinusoid[i] *= amplitude;\par
72         \}\par
73     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Add\:radio::PlTone}
{\xe \v radio::PlTone\:Add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void radio::PlTone::Add ()}}
\par
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds the CTCSS tone to the baseband signal. \par
}{
Definition at line 75 of file PlTone.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 75                      \{\par
76         for(uint32 i = 0; i < size; i++) \{\par
77             data[i] += amplitude * next();\par
78             data[i] /= (1 + amplitude);  // ensures value <= 1\par
79         \}\par
80     \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1PlTone_a9e19b2d5106b35626d4839f04f9b9f95_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1PlTone_a9e19b2d5106b35626d4839f04f9b9f95_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b PlTone.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
radio::Sinusoid Class Reference\par \pard\plain 
{\tc\tcl2 \v radio::Sinusoid}
{\xe \v radio::Sinusoid}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
\par
{
{\f2 #include <Sinusoid.hpp>}}\par
Inheritance diagram for radio::Sinusoid:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Sinusoid__inherit__graph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Sinusoid} ({\b float32} {\b frequency}, {\b uint32} {\b samplingRate}=48000)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Sinusoid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} {\b next} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} {\b nextShifted} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} {\b frequency}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32} {\b sinIndex} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32} {\b sinIndexShifted} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b uint32} {\b samplingRate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} * {\b sinusoid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b float32} * {\b sinusoidShift90}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This class creates an easy-to-call sinusoid that will preserve its phase throughout its lifespan. Essentially, it is a ring buffer. \par
}{
Definition at line 20 of file Sinusoid.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Sinusoid\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:Sinusoid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Sinusoid::Sinusoid ({\b float32} {\i frequency}, {\b uint32} {\i samplingRate} = {\f2 48000})}}
\par
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a ring-buffer sinusoid. \par
}{
Definition at line 77 of file Sinusoid.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 77                                                              \{\par
78         this->frequency = frequency;\par
79         this->samplingRate = samplingRate;\par
80         sinusoid = (float32*)std::malloc(samplingRate * sizeof(float32));\par
81         sinusoidShift90 = (float32*)std::malloc(samplingRate * sizeof(float32));\par
82 \par
83         float32 arg = 2 * M_PI * frequency / samplingRate;\par
84 \par
85         for(uint32 i = 0; i < samplingRate; i++) \{\par
86             // cosine argument evaluates as float due to M_PI and frequency\par
87             sinusoid[i] = cos(arg * i);\par
88             sinusoidShift90[i] = sin(arg * i);\par
89         \}\par
90     \}\par
}
}
{\xe \v ~Sinusoid\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:~Sinusoid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
radio::Sinusoid::~Sinusoid ()}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Free arrays malloc'd in the constructor. \par
}{
Definition at line 92 of file Sinusoid.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92                         \{\par
93         free(sinusoid);\par
94         free(sinusoidShift90);\par
95     \}\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v next\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32} radio::Sinusoid::next ()}}
\par
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides the next value of the sinusoid in a manner consistant with a ring buffer. \par
}{
Definition at line 97 of file Sinusoid.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 97                            \{\par
98         if(sinIndex >= samplingRate) sinIndex = 0;\par
99         return sinusoid[sinIndex++];\par
100     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Sinusoid_aab44298ea1bd5cb175d5826243cf56f2_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v nextShifted\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:nextShifted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32} radio::Sinusoid::nextShifted ()}}
\par
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Provides the next value of the sinusoid shifted 90 degrees in a manner consistant with a ring buffer. \par
}{
Definition at line 102 of file Sinusoid.hpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 102                                   \{\par
103         if(sinIndexShifted >= samplingRate) sinIndexShifted = 0;\par
104         return sinusoidShift90[sinIndexShifted++];\par
105     \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "classradio_1_1Sinusoid_a3f2741e9dd30291e5fa87f2eb2243e7c_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v frequency\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:frequency}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32} radio::Sinusoid::frequency{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The frequency of the sinusoid \par
}{
Definition at line 48 of file Sinusoid.hpp.}\par
}
{\xe \v samplingRate\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:samplingRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32} radio::Sinusoid::samplingRate{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The sampling rate \par
}{
Definition at line 63 of file Sinusoid.hpp.}\par
}
{\xe \v sinIndex\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:sinIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32} radio::Sinusoid::sinIndex = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current index of the sinusoid's unshifted array \par
}{
Definition at line 53 of file Sinusoid.hpp.}\par
}
{\xe \v sinIndexShifted\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:sinIndexShifted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b uint32} radio::Sinusoid::sinIndexShifted = 0{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The current index of the shifted sinusoid's array \par
}{
Definition at line 58 of file Sinusoid.hpp.}\par
}
{\xe \v sinusoid\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:sinusoid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32}* radio::Sinusoid::sinusoid{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialized as an array of the sinusoid values \par
}{
Definition at line 68 of file Sinusoid.hpp.}\par
}
{\xe \v sinusoidShift90\:radio::Sinusoid}
{\xe \v radio::Sinusoid\:sinusoidShift90}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b float32}* radio::Sinusoid::sinusoidShift90{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialized as an array of the sinusoid values shifted 90 degrees \par
}{
Definition at line 74 of file Sinusoid.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
src/{\b Sinusoid.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/bbftest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/bbftest}
{\xe \v bin/bbftest}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b bbftest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/lsbftest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/lsbftest}
{\xe \v bin/lsbftest}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b lsbftest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/modtest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/modtest}
{\xe \v bin/modtest}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b modtest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/msintest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/msintest}
{\xe \v bin/msintest}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b msintest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/pltest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/pltest}
{\xe \v bin/pltest}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b pltest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/radio File Reference\par \pard\plain 
{\tc\tcl2 \v bin/radio}
{\xe \v bin/radio}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b radio}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/sintest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/sintest}
{\xe \v bin/sintest}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b sintest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
bin/usbftest File Reference\par \pard\plain 
{\tc\tcl2 \v bin/usbftest}
{\xe \v bin/usbftest}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b usbftest}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
etc/doxygen.config File Reference\par \pard\plain 
{\tc\tcl2 \v etc/doxygen.config}
{\xe \v etc/doxygen.config}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains doxygen configuration. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains doxygen configuration. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b doxygen.config}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
makefile File Reference\par \pard\plain 
{\tc\tcl2 \v makefile}
{\xe \v makefile}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains recipes to compile the main program and the tests programs as well as making documentation and counting total lines of code in src/. }}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains recipes to compile the main program and the tests programs as well as making documentation and counting total lines of code in src/. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b makefile}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/alsa_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/alsa_test.cpp}
{\xe \v src/alsa_test.cpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests sinusoidal tone generation. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <climits>}\par
{\f2 #include <iostream>}\par
{\f2 #include <alsa/asoundlib.h>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for alsa_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "alsa__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests sinusoidal tone generation. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Clicking noise from sinusoidal discontinuity \par
}
}{
Definition in file {\b alsa_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:alsa_test.cpp}
{\xe \v alsa_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program tests sinusoidal speaker output through the ALSA API. Not sure if it works. When it did at least compile and run, it produced a sinusoid with an approximately twice-per-second clicking noise. \par
}{
Definition at line 22 of file alsa_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22            \{\par
23     int ret;\par
24 \par
25     snd_pcm_t* pcm_handle;  // device handle\par
26     snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;\par
27     snd_pcm_hw_params_t* hwparams;  // hardware information\par
28     char* pcm_name = strdup("plughw:1,0");  // on-board audio jack\par
29     int rate = 48000;\par
30 \par
31     const uint16 freq = 440;\par
32     long unsigned int bufferSize = 4096*4;  // anything >8192 causes seg fault\par
33     const uint32 len = bufferSize*100;\par
34     const float32 arg = 2 * 3.141592 * freq / rate;\par
35     sint16 vals[len];\par
36 \par
37     long unsigned int count = 0;\par
38 \par
39     for(uint32 i = 0; i < len; i = i + 2) \{\par
40         vals[i] = (sint16)(SHRT_MAX * cos(arg * i/2) + 0.5);\par
41         vals[i+1] = vals[i];\par
42     \}\par
43 \par
44     ret = snd_pcm_open(&pcm_handle, pcm_name, stream, 0);\par
45     cout << "Opening: " << snd_strerror(ret) << endl;\par
46 \par
47     ret = snd_pcm_hw_params_any(pcm_handle, hwparams);\par
48     cout << "Initializing hwparams structure: " << snd_strerror(ret) << endl;   \par
49 \par
50     ret = snd_pcm_hw_params_set_access(pcm_handle, hwparams,\par
51             SND_PCM_ACCESS_RW_INTERLEAVED);\par
52     cout << "Setting access: " << snd_strerror(ret) << endl;\par
53 \par
54     ret = snd_pcm_hw_params_set_format(pcm_handle, hwparams,\par
55             SND_PCM_FORMAT_S16_LE);\par
56     cout << "Setting format: " << snd_strerror(ret) << endl;\par
57 \par
58     ret = snd_pcm_hw_params_set_rate(pcm_handle, hwparams,\par
59             rate, (int)0);\par
60     cout << "Setting rate: " << snd_strerror(ret) << endl;\par
61 \par
62     ret = snd_pcm_hw_params_set_channels(pcm_handle, hwparams, 2); \par
63     cout << "Setting channels: " << snd_strerror(ret) << endl;\par
64 \par
65     ret = snd_pcm_hw_params_set_periods(pcm_handle, hwparams, 2, 0);\par
66     cout << "Setting periods: " << snd_strerror(ret) << endl;\par
67 \par
68     ret = snd_pcm_hw_params_set_buffer_size_near(pcm_handle, hwparams,\par
69             &bufferSize);\par
70     cout << "Setting buffer size: " << snd_strerror(ret) << endl;\par
71 \par
72     ret = snd_pcm_hw_params(pcm_handle, hwparams);\par
73     cout << "Applying parameters: " << snd_strerror(ret) << endl;\par
74 \par
75 //  ret = snd_pcm_hw_params_get_period_size(hwparams, &count, 0);\par
76     cout << "Actual period size: " << count << endl;\par
77     cout << "Returned: " << snd_strerror(ret) << endl;\par
78 \par
79 \par
80 \par
81     cout << endl << endl;\par
82 \par
83 \par
84     const void* ptr[100];\par
85 \par
86     for(int i = 0; i < 100; i++) \{\par
87         ptr[i] = (const void*)&vals + bufferSize*i;\par
88     \}\par
89 \par
90     int err;\par
91 \par
92     for(int i = 0; i < 100; i++) \{\par
93         do \{\par
94             ret = snd_pcm_writei(pcm_handle,\par
95                     ptr[i], count);\par
96 \par
97             if(ret < 0) \{\par
98                 err = snd_pcm_prepare(pcm_handle);\par
99                 cout << "Preparing: " << snd_strerror(err)\par
100                     << endl;\par
101             \}\par
102         \} while(ret < 0);\par
103 \par
104         cout << "Writing data: " << ret << endl;\par
105     \}\par
106 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/auxiliary.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/auxiliary.hpp}
{\xe \v src/auxiliary.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains helper-functions for {\b main()}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <climits>}\par
{\f2 #include <iostream>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <string>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for auxiliary.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "auxiliary_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::ShowHelp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::to_sint32} ({\b float32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ModulationType {\b radio::to_type} (std::string str)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains helper-functions for {\b main()}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b auxiliary.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/baseband_filter_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/baseband_filter_test.cpp}
{\xe \v src/baseband_filter_test.cpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to demonstrate the the baseband/AF filter. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "fvectors.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for baseband_filter_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "baseband__filter__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains a program to demonstrate the the baseband/AF filter. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b baseband_filter_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:baseband_filter_test.cpp}
{\xe \v baseband_filter_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Filter class and the baseband filter coefficients. \par
}{
Definition at line 25 of file baseband_filter_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                  \{\par
26 \par
27     // Constants\par
28     const uint16 BUFFER_SIZE = 48000;\par
29 \par
30     // Declare primative Variables\par
31     uint8 i = 0;\par
32     uint8 size = 0;\par
33     uint16 delta = 250;\par
34     float32 dataBuffer[BUFFER_SIZE];\par
35     float32 iqBuffer[2 * BUFFER_SIZE];\par
36 \par
37     // create 1 sec of audio\par
38     for(uint16 f = delta; f <= 3000; f += delta, i++) \{\par
39         Sinusoid sinusoid(f);\par
40 \par
41         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
42             dataBuffer[i] += sinusoid.next();\par
43         \}\par
44     \}\par
45 \par
46     size = i;\par
47     \par
48     // adjust dataBuffer so values are between -1 and 1\par
49     for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
50         dataBuffer[i] /= size;\par
51     \}\par
52     \par
53     Filter filter(dataBuffer, BUFFER_SIZE, F_BASEBAND);\par
54     filter.Pass();\par
55     makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
56     to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
57 \par
58     while(true) \{\par
59         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
60     \}\par
61 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "baseband__filter__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/definitions.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/definitions.hpp}
{\xe \v src/definitions.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declarations of system-independant (universal size) integers and float types, shortened type names for some commonly used types, and enumerations. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include <vector>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for definitions.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "definitions_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "definitions_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ENUM}\~ signed char\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b ERROR}\~ -1\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b byte}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b uint8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed char {\b sint8}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b uint16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed short {\b sint16}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b uint32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed int {\b sint32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long long {\b uint64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef signed long long {\b sint64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef float {\b float32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b float64}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::complex< {\b float32} > {\b cfloat32}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector\par
< std::vector< {\b float64} > > {\b fparams}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b radio::Age} \{ {\b radio::OLD}, 
{\b radio::NEW}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b radio::Fractional} \{ {\b radio::NUM}, 
{\b radio::DEN}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b radio::Argument} \{ {\b radio::FREQ} = 1, 
{\b radio::MODE}, 
{\b radio::PL_TONE}
 \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b radio::ModulationType} \{ {\b radio::ModulationType::DSB_LC}, 
{\b radio::ModulationType::DSB_SC}, 
{\b radio::ModulationType::USB_FILTERED}, 
{\b radio::ModulationType::USB_HILBERT}, 
{\b radio::ModulationType::LSB_FILTERED}, 
{\b radio::ModulationType::LSB_HILBERT}, 
{\b radio::ModulationType::FM_NARROW}, 
{\b radio::ModulationType::FM_WIDE}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains declarations of system-independant (universal size) integers and float types, shortened type names for some commonly used types, and enumerations. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b definitions.hpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v ENUM\:definitions.hpp}
{\xe \v definitions.hpp\:ENUM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ENUM\~ signed char}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 15 of file definitions.hpp.}\par
}
{\xe \v ERROR\:definitions.hpp}
{\xe \v definitions.hpp\:ERROR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define ERROR\~ -1}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 16 of file definitions.hpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v byte\:definitions.hpp}
{\xe \v definitions.hpp\:byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b byte}}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 18 of file definitions.hpp.}\par
}
{\xe \v cfloat32\:definitions.hpp}
{\xe \v definitions.hpp\:cfloat32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::complex<{\b float32}> {\b cfloat32}}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a type for complex float32's. \par
}{
Definition at line 37 of file definitions.hpp.}\par
}
{\xe \v float32\:definitions.hpp}
{\xe \v definitions.hpp\:float32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef float {\b float32}}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 31 of file definitions.hpp.}\par
}
{\xe \v float64\:definitions.hpp}
{\xe \v definitions.hpp\:float64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double {\b float64}}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 32 of file definitions.hpp.}\par
}
{\xe \v fparams\:definitions.hpp}
{\xe \v definitions.hpp\:fparams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<std::vector<{\b float64}> > {\b fparams}}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines a type for the filter coefficients. \par
}{
Definition at line 42 of file definitions.hpp.}\par
}
{\xe \v sint16\:definitions.hpp}
{\xe \v definitions.hpp\:sint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed short {\b sint16}}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 23 of file definitions.hpp.}\par
}
{\xe \v sint32\:definitions.hpp}
{\xe \v definitions.hpp\:sint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed int {\b sint32}}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 26 of file definitions.hpp.}\par
}
{\xe \v sint64\:definitions.hpp}
{\xe \v definitions.hpp\:sint64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed long long {\b sint64}}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 29 of file definitions.hpp.}\par
}
{\xe \v sint8\:definitions.hpp}
{\xe \v definitions.hpp\:sint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef signed char {\b sint8}}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 20 of file definitions.hpp.}\par
}
{\xe \v uint16\:definitions.hpp}
{\xe \v definitions.hpp\:uint16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short {\b uint16}}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 22 of file definitions.hpp.}\par
}
{\xe \v uint32\:definitions.hpp}
{\xe \v definitions.hpp\:uint32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int {\b uint32}}}
\par
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 25 of file definitions.hpp.}\par
}
{\xe \v uint64\:definitions.hpp}
{\xe \v definitions.hpp\:uint64}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long long {\b uint64}}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 28 of file definitions.hpp.}\par
}
{\xe \v uint8\:definitions.hpp}
{\xe \v definitions.hpp\:uint8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char {\b uint8}}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 19 of file definitions.hpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fft_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/fft_test.cpp}
{\xe \v src/fft_test.cpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include <functional>}\par
{\f2 #include <iostream>}\par
{\f2 #include <valarray>}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for fft_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::valarray\par
< std::complex< double > > {\b CArray}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b fft} ({\b CArray} &x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ifft} ({\b CArray} &x)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::complex< double > {\b hilbert} (std::complex< double > n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b PI} = 3.141592653589793238460\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b fft_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CArray\:fft_test.cpp}
{\xe \v fft_test.cpp\:CArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::valarray<std::complex<double> > {\b CArray}}}
\par
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 14 of file fft_test.cpp.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v fft\:fft_test.cpp}
{\xe \v fft_test.cpp\:fft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void fft ({\b CArray} & {\i x})}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This code was taken from {\f2 http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}. \par
}{
Definition at line 23 of file fft_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24 \{\par
25     // DFT\par
26     unsigned int N = x.size(), k = N, n;\par
27     double thetaT = 3.14159265358979323846264338328L / N;\par
28     std::complex<double> phiT(cos(thetaT), sin(thetaT)), T;\par
29     while (k > 1)\par
30     \{\par
31         n = k;\par
32         k >>= 1;\par
33         phiT = phiT * phiT;\par
34         T = 1.0L;\par
35         for (unsigned int l = 0; l < k; l++)\par
36         \{\par
37             for (unsigned int a = l; a < N; a += n)\par
38             \{\par
39                 unsigned int b = a + k;\par
40                 std::complex<double> t = x[a] - x[b];\par
41                 x[a] += x[b];\par
42                 x[b] = t * T;\par
43             \}\par
44             T *= phiT;\par
45         \}\par
46     \}\par
47     // Decimate\par
48     unsigned int m = (unsigned int)log2(N);\par
49     for (unsigned int a = 0; a < N; a++)\par
50     \{\par
51         unsigned int b = a;\par
52         // Reverse bits\par
53         b = (((b & 0xaaaaaaaa) >> 1) | ((b & 0x55555555) << 1));\par
54         b = (((b & 0xcccccccc) >> 2) | ((b & 0x33333333) << 2));\par
55         b = (((b & 0xf0f0f0f0) >> 4) | ((b & 0x0f0f0f0f) << 4));\par
56         b = (((b & 0xff00ff00) >> 8) | ((b & 0x00ff00ff) << 8));\par
57         b = ((b >> 16) | (b << 16)) >> (32 - m);\par
58         if (b > a)\par
59         \{\par
60             std::complex<double> t = x[a];\par
61             x[a] = x[b];\par
62             x[b] = t;\par
63         \}\par
64     \}\par
66     //std::complex<double> f = 1.0 / sqrt(N);\par
67     //for (unsigned int i = 0; i < N; i++)\par
68     //  x[i] *= f;\par
69 \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp_a22051cd252d576aec530227d32d95bdd_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v hilbert\:fft_test.cpp}
{\xe \v fft_test.cpp\:hilbert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::complex<double> hilbert (std::complex< double > {\i n})}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 87 of file fft_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 87                                                  \{\par
88     return std::complex<double>(-2 * n.imag(), 0);\par
89 \}\par
}
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp_adc49b5a69e64611f421bbefee39a4d15_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v ifft\:fft_test.cpp}
{\xe \v fft_test.cpp\:ifft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ifft ({\b CArray} & {\i x})}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 72 of file fft_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 73 \{\par
74     // conjugate the complex numbers\par
75     x = x.apply(std::conj);\par
76 \par
77     // forward fft\par
78     fft( x );\par
79 \par
80     // conjugate the complex numbers again\par
81     x = x.apply(std::conj);\par
82 \par
83     // scale the numbers\par
84     x /= x.size();\par
85 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp_a6234aee8acb83780e803805365617f36_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
{
Here is the caller graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp_a6234aee8acb83780e803805365617f36_icgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\xe \v main\:fft_test.cpp}
{\xe \v fft_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 91 of file fft_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 92 \{\par
93     const std::complex<double> test[] = \{ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 \};\par
94     CArray data(test, 16);\par
95 \par
96     // forward fft\par
97     fft(data);\par
98 \par
99     std::cout << "fft" << std::endl;\par
100     for (int i = 0; i < 16; ++i)\par
101     \{\par
102     //  std::cout << data[i] << std::endl;\par
103     \}\par
104 \par
105     for(int i = 8; i < 16; i++) \{\par
106         data[i] = 0;\par
107     \}\par
108 \par
109     // inverse fft\par
110     ifft(data);\par
111     std::cout << std::endl << "ifft" << std::endl;\par
112 \par
113     for (int i = 0; i < 16; ++i)\par
114     \{\par
115     //  std::cout << data[i] << std::endl;\par
116     \}\par
117 \par
118     data = data.apply(hilbert);\par
119 \par
120     std::cout << std::endl;\par
121 \par
122     for(int i = 0; i < 16; i++) \{\par
123         std::cout << data[i].real() << std::endl;\par
124     \}\par
125 \par
126     return 0;\par
127 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v PI\:fft_test.cpp}
{\xe \v fft_test.cpp\:PI}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double PI = 3.141592653589793238460}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line 12 of file fft_test.cpp.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fft_test2.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/fft_test2.cpp}
{\xe \v src/fft_test2.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations in {\b zdomain.hpp}. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include <iostream>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for fft_test2.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test2_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests FFT, IFFT, and Hilbert implementations in {\b zdomain.hpp}. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b fft_test2.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:fft_test2.cpp}
{\xe \v fft_test2.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program tests the {\b fft()}, {\b ifft()}, and {\b hilbert()} functions in the {\b zdomain.hpp} file.\par
This code is based on code from {\f2 http://rosettacode.org/wiki/Fast_Fourier_transform#C.2B.2B}. \par
}{
Definition at line 22 of file fft_test2.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23 \{\par
24     std::complex<float32> test[] = \{ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16 \};\par
25     float32 ftest[16];  \par
26     float32 dest[16];\par
27 \par
28     for(int i = 0; i < 16; i++) \{\par
29         ftest[i] = test[i].real();\par
30     \}\par
31 \par
32     // forward fft\par
33     fft(test, 16);\par
34 \par
35     std::cout << "fft" << std::endl;\par
36 \par
37     for (int i = 0; i < 16; ++i)\par
38     \{\par
39     //  std::cout << test[i] << std::endl;\par
40     \}\par
41 \par
42     // inverse fft\par
43     ifft(test, 16);\par
44     std::cout << std::endl << "ifft" << std::endl;\par
45 \par
46     for (int i = 0; i < 16; ++i)\par
47     \{\par
48         std::cout << test[i] << std::endl;\par
49     \}\par
50 \par
51     hilbert(ftest, dest, 16);\par
52     std::cout << std::endl << "hilbert" << std::endl;\par
53 \par
54     for(int i = 0; i < 16; i++) \{\par
55         std::cout << dest[i] << std::endl;\par
56     \}\par
57 \par
58     return 0;\par
59 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fft__test2_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Filter.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Filter.hpp}
{\xe \v src/Filter.hpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the Filter class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <vector>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Filter.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Filter_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Filter_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b radio::Filter}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the Filter class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid discontinuities created at the beginning of each pass \par
}
}{
Definition in file {\b Filter.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/fvectors.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/fvectors.hpp}
{\xe \v src/fvectors.hpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the transfer function coefficients used in the instances of the Filter class in this program. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for fvectors.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fvectors_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "fvectors_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b radio::F_BASEBAND}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b radio::F_LOWERSIDEBAND}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b fparams} {\b radio::F_UPPERSIDEBAND}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Defines the transfer function coefficients used in the instances of the Filter class in this program. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b fvectors.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Gain.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Gain.hpp}
{\xe \v src/Gain.hpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Gain class. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Gain.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Gain_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Gain_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b radio::Gain}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the Gain class. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Gain.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/iq_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/iq_test.cpp}
{\xe \v src/iq_test.cpp}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates test IQ signal. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for iq_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "iq__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generates test IQ signal. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b iq_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:iq_test.cpp}
{\xe \v iq_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This small program demonstrates the IQ generation abilities of the {\b makeIQ()} function. \par
}{
Definition at line 20 of file iq_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 20            \{\par
21     const uint16 len = 16384;\par
22     float32 data[len];\par
23     float32 iqData[2*len];\par
24 \par
25     for(int i = 0; i < len; i++) \{\par
26         data[i] = sin(2*3.141592*170*i/len);\par
27     \}\par
28 \par
29     while(true) \{\par
30         read(STDIN_FILENO, &data, len * sizeof(float32));\par
31         makeIQ(data, iqData, len);\par
32         write(STDOUT_FILENO, &iqData,  2 * len * sizeof(float32));\par
33     \}\par
34 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "iq__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/lsb_filter_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/lsb_filter_test.cpp}
{\xe \v src/lsb_filter_test.cpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "fvectors.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for lsb_filter_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "lsb__filter__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:lsb_filter_test.cpp}
{\xe \v lsb_filter_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Filter class and the LSB filter coefficients. \par
}{
Definition at line 25 of file lsb_filter_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                  \{\par
26 \par
27     // Constants\par
28     const uint16 BUFFER_SIZE = 48000;\par
29 \par
30     // Declare primative Variables\par
31     uint8 i = 0;\par
32     uint8 size = 0;\par
33     uint16 delta = 250;\par
34     float32 dataBuffer[BUFFER_SIZE];\par
35     float32 iqBuffer[2 * BUFFER_SIZE];\par
36 \par
37     // create 1 sec of audio\par
38     for(uint16 f = 17000; f <= 23000; f += delta, i++) \{\par
39         Sinusoid sinusoid(f);\par
40 \par
41         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
42             dataBuffer[i] += sinusoid.next();\par
43         \}\par
44     \}\par
45 \par
46     size = i;\par
47     \par
48     // adjust dataBuffer so values are between -1 and 1\par
49     for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
50         dataBuffer[i] /= size;\par
51     \}\par
52     \par
53     Filter filter(dataBuffer, BUFFER_SIZE, F_LOWERSIDEBAND);\par
54     filter.Pass();\par
55     makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
56     to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
57 \par
58     while(true) \{\par
59         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
60     \}\par
61 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "lsb__filter__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/main.cpp}
{\xe \v src/main.cpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the "brains" of the entire project }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <iostream>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "Gain.hpp"}\par
{\f2 #include "Modulator.hpp"}\par
{\f2 #include "PlTone.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for main.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the "brains" of the entire project \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b main.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Final result of the entire project. Completes all goals and more! \par
}{
Definition at line 26 of file main.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 26                                  \{\par
27 \par
28     // Constants\par
29     const uint8 NUM_TYPES = 8;\par
30     const uint16 BUFFER_SIZE = 16384;\par
31     const uint32 BUFFER_BYTE_COUNT = BUFFER_SIZE * sizeof(sint32);\par
32     const uint32 IQ_BUFFER_SIZE = 2 * BUFFER_SIZE;\par
33     const uint32 IQ_BUFFER_BYTE_COUNT = BUFFER_BYTE_COUNT * 2;\par
34     const uint32 SAMPLING_RATE = 48000;\par
35 \par
36     // Ensure 1 or 2 arguments given\par
37     if(argc > 4) \{\par
38         std::cerr << "Error: too many arguments!" << std::endl;\par
39         ShowHelp();\par
40         return ERROR;\par
41     \} else if(argc < 2) \{\par
42         std::cerr << "Error: too few arguments!" << std::endl;\par
43         ShowHelp();\par
44         return ERROR;\par
45     \}\par
46 \par
47     // Declare primative Variables\par
48     float32 micGain = 0;\par
49     float32 toneFreq = 0;\par
50     float32 dataBuffer[BUFFER_SIZE];\par
51     float32 iqBuffer[IQ_BUFFER_SIZE];\par
52     ModulationType type;\par
53 \par
54     // validate modulation type\par
55     try\{\par
56         type = to_type(string(argv[1]));\par
57     \} catch(std::exception ex) \{\par
58         std::cerr << "The given modulation type is invalid!" << std::endl;\par
59         ShowHelp();\par
60     \}\par
61 \par
62     // process mic gain\par
63     if(argc >= 3) \{\par
64         try \{\par
65             micGain = std::stof(argv[2]);\par
66         \} catch(std::invalid_argument ex) \{\par
67             std::cerr << "The specified microphone gain is not a number."\par
68                 << std::endl;\par
69             ShowHelp();\par
70         \}\par
71     \}\par
72 \par
73     // validate CTCSS tone\par
74     if(argc == 4) \{\par
75         try \{\par
76             toneFreq = std::stof(argv[3]);\par
77 \par
78             if(toneFreq < 60 || toneFreq > 260) \{\par
79                 throw std::out_of_range("");\par
80             \}\par
81         \} catch(std::out_of_range ex) \{\par
82             std::cerr << "The specified CTCSS frequency is outside of the "\par
83                 "standard PL tone range." << std::endl;\par
84             ShowHelp();\par
85         \} catch(std::invalid_argument ex) \{\par
86             std::cerr << "The specified CTCSS frequency is not a number."\par
87                 << std::endl;\par
88             ShowHelp();\par
89         \}\par
90     \}\par
91 \par
92     // Declare objects\par
93     Filter baseFilter(dataBuffer, BUFFER_SIZE, F_BASEBAND);\par
94     Gain gain(dataBuffer, BUFFER_SIZE, micGain);\par
95     PlTone pltone(0.15, dataBuffer, BUFFER_SIZE, toneFreq, SAMPLING_RATE);\par
96     Modulator modulator(dataBuffer, BUFFER_SIZE, type, 20000);\par
97 \par
98     // SDR guts of the program\par
99     while(true) \{\par
100         // get next samples\par
101         read(STDIN_FILENO, &dataBuffer, BUFFER_BYTE_COUNT);\par
102         \par
103         // process/modulate samples\par
104         baseFilter.Pass();\par
105 //      pltone.Add();\par
106         gain.Apply();\par
107         modulator.Mod();\par
108         makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
109         to_sint32(iqBuffer, IQ_BUFFER_SIZE);\par
110         \par
111         // write samples\par
112         write(STDOUT_FILENO, &iqBuffer, IQ_BUFFER_BYTE_COUNT);\par
113     \}\par
114 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "main_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/mic_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/mic_test.cpp}
{\xe \v src/mic_test.cpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests getting mic input via ALSA  May not even compile at the moment. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <climits>}\par
{\f2 #include <iostream>}\par
{\f2 #include <alsa/asoundlib.h>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for mic_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "mic__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests getting mic input via ALSA  May not even compile at the moment. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b mic_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:mic_test.cpp}
{\xe \v mic_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This program tests taking information from the microphone via the ALSA API. Not sure if it works. \par
}{
Definition at line 21 of file mic_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 21            \{\par
22     int ret;\par
23 \par
24     snd_pcm_t* pcm_handle;  // device handle\par
25 //  snd_pcm_stream_t stream = SND_PCM_STREAM_PLAYBACK;\par
26     snd_pcm_stream_t stream = SND_PCM_STREAM_CAPTURE;\par
27     snd_pcm_hw_params_t* hwparams;  // hardware information\par
28     char* pcm_name = strdup("plughw:1,0");  // on-board audio jack\par
29     //char* pcm_name = strdup("plughw:0,0");  // on-board audio jack\par
30     int rate = 48000;\par
31 \par
32     const uint16 freq = 440;\par
33     long unsigned int bufferSize = 8192*4;\par
34     const uint32 len = bufferSize*100;\par
35     const float32 arg = 2 * 3.141592 * freq / rate;\par
36     sint16 vals[len];\par
37 \par
38     float test;\par
39     float last = 0;\par
40     long unsigned int count = 0;\par
41     int count2 = 0;\par
42 \par
43     for(int i = 0; i < len; i = i + 2) \{\par
44         bool lastWas = abs(sin(last)) < 0.01;\par
45 \par
46         last += arg;\par
47         if(last > 2 * M_PI) last -= 2 * M_PI;\par
48 \par
49         test = 32000 * sin(last);\par
50 \par
51         if(abs(sin(last)) < 0.01 && lastWas) count++;\par
52 \par
53         vals[i] = (sint16)(test + 0.5);\par
54         vals[i+1] = vals[i];\par
55     \}\par
56 \par
57     cout << "COUNT: " << count << endl;\par
58     snd_pcm_hw_params_alloca(&hwparams);\par
59 \par
60     ret = snd_pcm_open(&pcm_handle, pcm_name, stream, 0);\par
61     cout << "Opening: " << snd_strerror(ret) << endl;\par
62 \par
63     ret = snd_pcm_hw_params_any(pcm_handle, hwparams);\par
64     cout << "Initializing hwparams structure: " << snd_strerror(ret) << endl;   \par
65 \par
66     ret = snd_pcm_hw_params_set_access(pcm_handle, hwparams,\par
67             SND_PCM_ACCESS_RW_INTERLEAVED);\par
68     cout << "Setting access: " << snd_strerror(ret) << endl;\par
69 \par
70     ret = snd_pcm_hw_params_set_format(pcm_handle, hwparams,\par
71             SND_PCM_FORMAT_S16_LE);\par
72     cout << "Setting format: " << snd_strerror(ret) << endl;\par
73 \par
74     ret = snd_pcm_hw_params_set_rate(pcm_handle, hwparams,\par
75             rate, (int)0);\par
76     cout << "Setting rate: " << snd_strerror(ret) << endl;\par
77 \par
78     ret = snd_pcm_hw_params_set_channels(pcm_handle, hwparams, 2); \par
79     cout << "Setting channels: " << snd_strerror(ret) << endl;\par
80 \par
81     ret = snd_pcm_hw_params_set_periods(pcm_handle, hwparams, 2, 0);\par
82     cout << "Setting periods: " << snd_strerror(ret) << endl;\par
83 \par
84     ret = snd_pcm_hw_params_set_buffer_size_near(pcm_handle, hwparams,\par
85             &bufferSize);\par
86     cout << "Setting buffer size: " << snd_strerror(ret) << endl;\par
87 \par
88     ret = snd_pcm_hw_params(pcm_handle, hwparams);\par
89     cout << "Applying parameters: " << snd_strerror(ret) << endl;\par
90 \par
91 /*  ret = snd_pcm_hw_params_get_period_size(hwparams, &count, &count2);\par
92     cout << "Actual period size: " << count << endl;\par
93     cout << "Returned: " << snd_strerror(ret) << endl;*/\par
94 \par
95     \par
96 \par
97     cout << endl << endl;\par
98 \par
99 \par
100     //const void* ptr = (const void*)&vals;\par
101     void* ptr = (void*)&vals;\par
102     int err;\par
103 \par
104     for(int i = 0; i < 100; i++) \{\par
105         do \{\par
106             ret = snd_pcm_readi(pcm_handle,\par
107                     ptr, bufferSize);\par
108 \par
109             if(ret < 0) \{\par
110                 err = snd_pcm_prepare(pcm_handle);\par
111                 cout << "Preparing: " << snd_strerror(err)\par
112                     << endl;\par
113             \}\par
114         \} while(ret < 0);\par
115 \par
116         cout << "Writing data: " << ret << endl;\par
117     \}\par
118 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Modulator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Modulator.hpp}
{\xe \v src/Modulator.hpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <array>}\par
{\f2 #include <cmath>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <vector>}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "fvectors.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Modulator.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Modulator_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Modulator_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b radio::Modulator}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b uint32} {\b radio::FREQ_INTERMEDIATE} = 20000\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b uint32} {\b radio::SAMPLING_RATE} = 48000\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/modulator_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/modulator_test.cpp}
{\xe \v src/modulator_test.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the Modulator class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "Modulator.hpp"}\par
{\f2 #include "PlTone.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for modulator_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "modulator__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the Modulator class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Bug:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid filtered SSB clicking \par
}
}{
Definition in file {\b modulator_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:modulator_test.cpp}
{\xe \v modulator_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Modulator class with a self-generated sinusoidal input. \par
}{
Definition at line 24 of file modulator_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                  \{\par
25 \par
26     // Constants\par
27     const uint16 BUFFER_SIZE = 16384;\par
28 \par
29     // Declare primative Variables\par
30     float32 dataBuffer[BUFFER_SIZE];\par
31     float32 iqBuffer[2 * BUFFER_SIZE];\par
32     ModulationType type;\par
33     float32 freq = atof(argv[2]);\par
34     float32 tone = 0;\par
35 \par
36     if(argc >= 4) tone = atof(argv[3]);\par
37 \par
38     try\{\par
39         type = to_type(string(argv[1]));\par
40     \} catch(std::exception ex) \{\par
41         std::cerr << ex.what() << std::endl << std::endl;\par
42         return ERROR;\par
43     \}\par
44 \par
45     if(freq < 0) \{\par
46         cerr << "The given tone was invalid." << endl;\par
47         return ERROR;\par
48     \}\par
49 \par
50     // Declare objects\par
51     Modulator modulator(dataBuffer, BUFFER_SIZE, type, 20000);\par
52     Sinusoid sinusoid(freq);\par
53     PlTone(tone > 0 ? 0.15 : 0, dataBuffer, BUFFER_SIZE, tone, 48000);\par
54 \par
55     while(true) \{\par
56         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
57             dataBuffer[i] = sinusoid.next();\par
58         \}\par
59 \par
60         modulator.Mod();\par
61         makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
62         to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
63         write(STDOUT_FILENO, &iqBuffer,  2 * BUFFER_SIZE * sizeof(sint32));\par
64     \}\par
65 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "modulator__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/multi_sinusoid_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/multi_sinusoid_test.cpp}
{\xe \v src/multi_sinusoid_test.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a program to demonstrate the ability of the Sinusoid class and the sound card to generate sinusoids accross the spectrum. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <vector>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for multi_sinusoid_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "multi__sinusoid__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a program to demonstrate the ability of the Sinusoid class and the sound card to generate sinusoids accross the spectrum. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b multi_sinusoid_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:multi_sinusoid_test.cpp}
{\xe \v multi_sinusoid_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Sinusoid class and demonstrate the frequency range of the sound card. \par
}{
Definition at line 27 of file multi_sinusoid_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 27                                  \{\par
28 \par
29     // Constants\par
30     const uint16 BUFFER_SIZE = 48000;\par
31 \par
32     // Declare primative Variables\par
33     uint8 i = 0;\par
34     uint8 size = 0;\par
35     uint16 delta = 100;\par
36     float32 dataBuffer[BUFFER_SIZE];\par
37     float32 iqBuffer[2 * BUFFER_SIZE];\par
38 \par
39     for(uint16 f = 100; f < 24000; f += delta, i++) \{\par
40         Sinusoid sinusoid(f);\par
41 \par
42         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
43             dataBuffer[i] += sinusoid.next();\par
44         \}\par
45 \par
46         switch(f) \{\par
47             case 500:\par
48                 delta = 1000;\par
49                 f = 1000;\par
50                 break;\par
51 \par
52             case 2000:\par
53                 delta = 2000;\par
54                 break;\par
55         \}\par
56     \}\par
57 \par
58     size = i;\par
59     \par
60     for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
61         dataBuffer[i] /= size;\par
62     \}\par
63     \par
64     makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
65     to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
66 \par
67     while(true) \{\par
68         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
69     \}\par
70 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "multi__sinusoid__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/piped_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/piped_test.cpp}
{\xe \v src/piped_test.cpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
containts the original program used to test the piping-in idea }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "modulation.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for piped_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "piped__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
containts the original program used to test the piping-in idea \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b piped_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:piped_test.cpp}
{\xe \v piped_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program originally used to test whether baseband audio could be piped into the program in real time. \par
}{
Definition at line 22 of file piped_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 22            \{\par
23     const uint16 len = 16384;\par
24     float32 data[len];\par
25     float32 iqData[2*len];\par
26 \par
27     while(true) \{\par
28         read(STDIN_FILENO, &data, len * sizeof(float32));\par
29         makeIQ(data, iqData, len);\par
30         write(STDOUT_FILENO, &iqData,  2 * len * sizeof(float32));\par
31     \}\par
32 \par
33 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "piped__test_8cpp_ae66f6b31b5ad750f1fe042a706a4e3d4_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/pl_tone_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/pl_tone_test.cpp}
{\xe \v src/pl_tone_test.cpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the PlTone class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstring>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "PlTone.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for pl_tone_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pl__tone__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the PlTone class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b pl_tone_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:pl_tone_test.cpp}
{\xe \v pl_tone_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the PlTone class. \par
}{
Definition at line 24 of file pl_tone_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 24                                  \{\par
25     // Constants\par
26     const uint16 BUFFER_SIZE = 16384;\par
27 \par
28     // Declare primative Variables\par
29     float32 dataBuffer[BUFFER_SIZE];\par
30     float32 iqBuffer[2 * BUFFER_SIZE];\par
31     float32 freq = atof(argv[1]);\par
32 \par
33     if(freq < 0) \{\par
34         cerr << "The given tone was invalid." << endl;\par
35         return ERROR;\par
36     \}\par
37 \par
38     PlTone tone(0.15, dataBuffer, BUFFER_SIZE, freq, 48000);\par
39 \par
40     while(true) \{\par
41         for(uint16 i = 0; i < BUFFER_SIZE; i ++) \{\par
42             dataBuffer[i] = 1;\par
43         \}\par
44         \par
45         tone.Add();\par
46         makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
47         to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
48         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
49     \}\par
50 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "pl__tone__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/PlTone.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/PlTone.hpp}
{\xe \v src/PlTone.hpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the PlTone class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "definitions.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for PlTone.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "PlTone_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "PlTone_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b radio::PlTone}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the PlTone class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b PlTone.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/Sinusoid.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/Sinusoid.hpp}
{\xe \v src/Sinusoid.hpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the Sinusoid class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for Sinusoid.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Sinusoid_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "Sinusoid_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b radio::Sinusoid}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains the Sinusoid class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b Sinusoid.hpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/sinusoid_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/sinusoid_test.cpp}
{\xe \v src/sinusoid_test.cpp}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the Sinusoid class }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <string>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for sinusoid_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sinusoid__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
contains a test program to test the Sinusoid class \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b sinusoid_test.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:sinusoid_test.cpp}
{\xe \v sinusoid_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Sinusoid class. \par
}{
Definition at line 23 of file sinusoid_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 23                                  \{\par
24 \par
25     // Constants\par
26     const uint16 BUFFER_SIZE = 16384;\par
27 \par
28     // Declare primative Variables\par
29     float32 dataBuffer[BUFFER_SIZE];\par
30     float32 iqBuffer[2 * BUFFER_SIZE];\par
31     float32 freq = atof(argv[1]);\par
32 \par
33     if(freq < 0) \{\par
34         cerr << "The given tone was invalid." << endl;\par
35         return ERROR;\par
36     \}\par
37 \par
38     Sinusoid sinusoid(freq, 48000);\par
39 \par
40     while(true) \{\par
41         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
42             dataBuffer[i] = sinusoid.next();\par
43         \}\par
44         \par
45         makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
46         to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
47         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
48     \}\par
49 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "sinusoid__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/usb_filter_test.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/usb_filter_test.cpp}
{\xe \v src/usb_filter_test.cpp}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdio>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <iostream>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include "auxiliary.hpp"}\par
{\f2 #include "definitions.hpp"}\par
{\f2 #include "Filter.hpp"}\par
{\f2 #include "fvectors.hpp"}\par
{\f2 #include "Sinusoid.hpp"}\par
{\f2 #include "zdomain.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for usb_filter_test.cpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "usb__filter__test_8cpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:usb_filter_test.cpp}
{\xe \v usb_filter_test.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char * {\i argv}[])}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Program to test the Filter class and the USB filter coefficients. \par
}{
Definition at line 25 of file usb_filter_test.cpp.}\par
{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 25                                  \{\par
26 \par
27     // Constants\par
28     const uint16 BUFFER_SIZE = 48000;\par
29 \par
30     // Declare primative Variables\par
31     uint8 i = 0;\par
32     uint8 size = 0;\par
33     uint16 delta = 250;\par
34     float32 dataBuffer[BUFFER_SIZE];\par
35     float32 iqBuffer[2 * BUFFER_SIZE];\par
36 \par
37     // create 1 sec of audio\par
38     for(uint16 f = 17000; f <= 23000; f += delta, i++) \{\par
39         Sinusoid sinusoid(f);\par
40 \par
41         for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
42             dataBuffer[i] += sinusoid.next();\par
43         \}\par
44     \}\par
45 \par
46     size = i;\par
47     \par
48     // adjust dataBuffer so values are between -1 and 1\par
49     for(uint16 i = 0; i < BUFFER_SIZE; i++) \{\par
50         dataBuffer[i] /= size;\par
51     \}\par
52     \par
53     Filter filter(dataBuffer, BUFFER_SIZE, F_UPPERSIDEBAND);\par
54     filter.Pass();\par
55     makeIQ(dataBuffer, iqBuffer, BUFFER_SIZE);\par
56     to_sint32(iqBuffer, 2 * BUFFER_SIZE);\par
57 \par
58     while(true) \{\par
59         write(STDOUT_FILENO, &iqBuffer, 2 * BUFFER_SIZE * sizeof(sint32));\par
60     \}\par
61 \}\par
}
{
Here is the call graph for this function:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "usb__filter__test_8cpp_a0ddf1224851353fc92bfbff6f499fa97_cgraph.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
src/zdomain.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v src/zdomain.hpp}
{\xe \v src/zdomain.hpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the functions to manipulate sequential data in the frequency (z) domain. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include "definitions.hpp"}\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Include dependency graph for zdomain.hpp:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "zdomain_8hpp__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This graph shows which files directly or indirectly include this file:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "zdomain_8hpp__dep__incl.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
 {\b radio}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the classes for the various types of modulation supported by the program. }}}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::aconj} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::fft} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::hilbert} ({\b float32} *data, {\b float32} *dest, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::ifft} ({\b cfloat32} *data, {\b uint32} size)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b radio::makeIQ} ({\b float32} *data, {\b float32} *dest, {\b uint32} size)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Contains the functions to manipulate sequential data in the frequency (z) domain. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Author:\par}\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Samuel Andrew Wisner, {\f2 awisner94@gmail.com} \par
}}{
Definition in file {\b zdomain.hpp}.}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}